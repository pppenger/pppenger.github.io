<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>javabasic</title><link href='night/mermaid.dark.css' rel='stylesheet' type='text/css' />
<link href='night/codeblock.dark.css' rel='stylesheet' type='text/css' />
<link href='night/sourcemode.dark.css' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:first-child { margin-top: -20px; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


.cm-s-inner .cm-variable, .cm-s-inner .cm-operator, .cm-s-inner .cm-property { color: rgb(184, 191, 198); }
.cm-s-inner .cm-keyword { color: rgb(200, 143, 208); }
.cm-s-inner .cm-tag { color: rgb(125, 244, 106); }
.cm-s-inner .cm-attribute { color: rgb(117, 117, 228); }
.CodeMirror div.CodeMirror-cursor { border-left: 1px solid rgb(184, 191, 198); z-index: 3; }
.cm-s-inner .cm-string { color: rgb(210, 107, 107); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(218, 146, 74); }
.cm-s-inner .cm-header, .cm-s-inner .cm-def, .cm-s-inner.cm-header, .cm-s-inner.cm-def { color: rgb(141, 141, 240); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(87, 172, 87); }
.cm-s-inner .cm-hr { color: rgb(216, 213, 213); }
.cm-s-inner .cm-link { color: rgb(211, 211, 239); }
.cm-s-inner .cm-negative { color: rgb(217, 80, 80); }
.cm-s-inner .cm-positive { color: rgb(80, 230, 80); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta, .cm-s-inner .cm-qualifier { color: rgb(183, 179, 179); }
.cm-s-inner .cm-builtin { color: rgb(243, 179, 248); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(132, 182, 203); }
.cm-s-inner .cm-number { color: rgb(100, 171, 143); }
.cm-s-inner .cm-variable { color: rgb(184, 191, 198); }
.cm-s-inner .cm-variable-2 { color: rgb(159, 186, 213); }
.cm-s-inner .cm-variable-3 { color: rgb(28, 198, 133); }
.CodeMirror-selectedtext, .CodeMirror-selected { background: rgb(74, 137, 220); text-shadow: none; color: rgb(255, 255, 255) !important; }
.CodeMirror-gutters { border-right: none; }


:root { --bg-color: #363B40; --side-bar-bg-color: #2E3033; --text-color: #b8bfc6; --select-text-bg-color:#4a89dc; --control-text-color: #b7b7b7; --control-text-hover-color: #eee; --window-border: 1px solid #555; --active-file-bg-color: rgb(34, 34, 34); --active-file-border-color: #8d8df0; --active-file-text-color: white; --item-hover-bg-color: #70717d; --item-hover-text-color: white; --primary-color: #6dc1e7; --rawblock-edit-panel-bd: #4B535A; }
html { font-size: 16px; }
html, body { text-size-adjust: 100%; background: var(--bg-color); fill: currentcolor; }
#write { max-width: 914px; }
html, body, button, input, select, textarea, div.code-tooltip-content { color: rgb(184, 191, 198); border-color: transparent; }
div.code-tooltip, .md-hover-tip .md-arrow::after { background: rgb(75, 83, 90); }
.popover.bottom > .arrow::after { border-bottom-color: rgb(75, 83, 90); }
html, body, button, input, select, textarea { font-style: normal; line-height: 1.625rem; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; }
hr { height: 2px; border: 0px; margin: 24px 0px !important; }
h1, h2, h3, h4, h5, h6 { font-family: "Lucida Grande", Corbel, sans-serif; font-weight: normal; clear: both; word-wrap: break-word; margin: 0px; padding: 0px; color: rgb(222, 222, 222); }
h1 { font-size: 2.5rem; line-height: 2.75rem; margin-bottom: 1.5rem; letter-spacing: -1.5px; }
h2 { font-size: 1.63rem; line-height: 1.875rem; margin-bottom: 1.5rem; letter-spacing: -1px; font-weight: bold; }
h3 { font-size: 1.17rem; line-height: 1.5rem; margin-bottom: 1.5rem; letter-spacing: -1px; font-weight: bold; }
h4 { font-size: 1.12rem; line-height: 1.375rem; margin-bottom: 1.5rem; color: white; }
h5 { font-size: 0.97rem; line-height: 1.25rem; margin-bottom: 1.5rem; font-weight: bold; }
h6 { font-size: 0.93rem; line-height: 1rem; margin-bottom: 0.75rem; color: white; }
@media (min-width: 980px) {
  h3.md-focus::before, h4.md-focus::before, h5.md-focus::before, h6.md-focus::before { color: rgb(221, 221, 221); border: 1px solid rgb(221, 221, 221); border-radius: 3px; position: absolute; left: -1.64286rem; top: 0.357143rem; float: left; font-size: 9px; padding-left: 2px; padding-right: 2px; vertical-align: bottom; font-weight: normal; line-height: normal; }
  h3.md-focus::before { content: "h3"; }
  h4.md-focus::before { content: "h4"; }
  h5.md-focus::before { content: "h5"; top: 0px; }
  h6.md-focus::before { content: "h6"; top: 0px; }
}
a { text-decoration: none; outline: 0px; }
a:hover { outline: 0px; }
a:focus { outline: dotted thin; }
sup.md-footnote { background-color: rgb(85, 85, 85); color: rgb(221, 221, 221); }
p { word-wrap: break-word; }
p, ul, dd, ol, hr, address, pre, table, iframe, .wp-caption, .wp-audio-shortcode, .wp-video-shortcode { margin-top: 0px; margin-bottom: 1.5rem; }
li > blockquote { margin-bottom: 0px; }
audio:not([controls]) { display: none; }
[hidden] { display: none; }
.in-text-selection, ::selection { background: rgb(74, 137, 220); color: rgb(255, 255, 255); text-shadow: none; }
ul, ol { padding: 0px 0px 0px 1.875rem; }
ul { list-style: square; }
ol { list-style: decimal; }
ul ul, ol ol, ul ol, ol ul { margin: 0px; }
b, th, dt, strong { font-weight: bold; }
i, em, dfn, cite { font-style: italic; }
blockquote { margin: 35px 0px 1.875rem 1.875rem; border-left: 2px solid rgb(71, 77, 84); padding-left: 30px; }
pre, code, kbd, tt, var { background: rgba(0, 0, 0, 0.05); font-size: 0.875rem; font-family: Monaco, Consolas, "Andale Mono", "DejaVu Sans Mono", monospace; }
kbd { padding: 2px 4px; font-size: 90%; color: rgb(255, 255, 255); background-color: rgb(51, 51, 51); border-radius: 3px; box-shadow: rgba(0, 0, 0, 0.25) 0px -1px 0px inset; }
pre.md-fences { padding: 10px 30px; margin-bottom: 20px; border: 1px solid; }
.md-fences .code-tooltip { bottom: -3.2em; }
.enable-diagrams pre.md-fences[lang="sequence"] .code-tooltip, .enable-diagrams pre.md-fences[lang="flow"] .code-tooltip, .enable-diagrams pre.md-fences[lang="mermaid"] .code-tooltip { bottom: -2.2em; right: 4px; }
code, kbd, tt, var { padding: 2px 5px; }
table { max-width: 100%; width: 100%; border-collapse: collapse; border-spacing: 0px; }
th, td { padding: 5px 10px; vertical-align: top; }
a { transition: all 0.2s ease-in-out; }
hr { background: rgb(71, 77, 84); }
h1 { margin-top: 2em; }
a { color: rgb(224, 224, 224); text-decoration: underline; }
a:hover { color: rgb(255, 255, 255); }
.md-inline-math script { color: rgb(129, 177, 219); }
b, th, dt, strong { color: rgb(222, 222, 222); }
mark { background: rgb(211, 212, 14); }
blockquote { color: rgb(157, 162, 166); }
table a { color: rgb(222, 222, 222); }
th, td { border: 1px solid rgb(71, 77, 84); }
.task-list { padding-left: 0px; }
.md-task-list-item { padding-left: 1.25rem; }
.md-task-list-item > input { top: auto; }
.md-task-list-item > input::before { content: ""; display: inline-block; width: 0.875rem; height: 0.875rem; vertical-align: middle; text-align: center; border: 1px solid rgb(184, 191, 198); background-color: rgb(54, 59, 64); margin-top: -0.4rem; }
.md-task-list-item > input:checked::before, .md-task-list-item > input[checked]::before { content: "√"; font-size: 0.625rem; line-height: 0.625rem; color: rgb(222, 222, 222); }
.CodeMirror-gutters { background: var(--bg-color); border-right: 1px solid transparent; }
.auto-suggest-container { border: 0px; background-color: rgb(82, 92, 101); }
#typora-quick-open { background-color: rgb(82, 92, 101); }
#typora-quick-open input { background-color: rgb(82, 92, 101); border-width: 0px 0px 1px; border-top-style: initial; border-right-style: initial; border-left-style: initial; border-top-color: initial; border-right-color: initial; border-left-color: initial; border-image: initial; border-bottom-style: solid; border-bottom-color: grey; }
.typora-quick-open-item { background-color: inherit; color: inherit; }
.typora-quick-open-item.active, .typora-quick-open-item:hover { background-color: rgb(77, 139, 219); color: white; }
.typora-quick-open-item:hover { background-color: rgba(77, 139, 219, 0.8); }
.typora-search-spinner > div { background-color: rgb(255, 255, 255); }
#write pre.md-meta-block { border-bottom: 1px dashed rgb(204, 204, 204); background: transparent; padding-bottom: 0.6em; line-height: 1.6em; }
.btn, .btn .btn-default { background: transparent; color: rgb(184, 191, 198); }
.ty-table-edit { border-top: 1px solid gray; background-color: rgb(54, 59, 64); }
.popover-title { background: transparent; }
.md-image > .md-meta { color: rgb(187, 187, 187); background: transparent; }
.md-expand.md-image > .md-meta { color: rgb(221, 221, 221); }
#write > h3::before, #write > h4::before, #write > h5::before, #write > h6::before { border: none; border-radius: 0px; color: rgb(136, 136, 136); text-decoration: underline; left: -1.4rem; top: 0.2rem; }
#write > h3.md-focus::before { top: 2px; }
#write > h4.md-focus::before { top: 2px; }
.md-toc-item { color: rgb(168, 194, 220); }
#write div.md-toc-tooltip { background-color: rgb(54, 59, 64); }
.dropdown-menu .btn:hover, .dropdown-menu .btn:focus, .md-toc .btn:hover, .md-toc .btn:focus { color: white; background: black; }
#toc-dropmenu { background: rgba(50, 54, 59, 0.93); border: 1px solid rgba(253, 253, 253, 0.15); }
#toc-dropmenu .divider { background-color: rgb(155, 155, 155); }
.outline-expander::before { top: 2px; }
#typora-sidebar { box-shadow: none; border-right: none; }
.sidebar-tabs { border-bottom: 0px; }
#typora-sidebar:hover .outline-title-wrapper { border-left: 1px dashed; }
.outline-title-wrapper .btn { color: inherit; }
.outline-item:hover { border-color: rgb(54, 59, 64); background-color: rgb(54, 59, 64); color: white; }
h1.md-focus .md-attr, h2.md-focus .md-attr, h3.md-focus .md-attr, h4.md-focus .md-attr, h5.md-focus .md-attr, h6.md-focus .md-attr, .md-header-span .md-attr { color: rgb(140, 142, 146); display: inline; }
.md-comment { color: rgb(90, 149, 227); opacity: 1; }
.md-inline-math g, .md-inline-math svg { stroke: rgb(184, 191, 198) !important; fill: rgb(184, 191, 198) !important; }
[md-inline="inline_math"] { color: rgb(156, 178, 233); }
#math-inline-preview .md-arrow::after { background: black; }
.modal-content { background: var(--bg-color); border: 0px; }
.modal-title { font-size: 1.5em; }
.modal-content input { background-color: rgba(26, 21, 21, 0.51); color: white; }
.modal-content .input-group-addon { background-color: rgba(0, 0, 0, 0.17); color: white; }
.modal-backdrop { background-color: rgba(174, 174, 174, 0.7); }
.modal-content .btn-primary { border-color: var(--primary-color); }
.md-table-resize-popover { background-color: rgb(75, 83, 90); }
.form-inline .input-group .input-group-addon { color: white; }
#md-searchpanel { border-bottom: 1px dashed grey; }
.context-menu, #spell-check-panel, #footer-word-count-info { background-color: rgb(66, 70, 74); }
.context-menu.dropdown-menu .divider, .dropdown-menu .divider { background-color: rgb(119, 119, 119); }
footer { color: inherit; }
@media (max-width: 1000px) {
  footer { border-top: none; }
  footer:hover { color: inherit; }
}
#file-info-file-path .file-info-field-value:hover { background-color: rgb(85, 85, 85); color: rgb(222, 222, 222); }
.megamenu-content, .megamenu-opened header { background: var(--bg-color); }
.megamenu-menu-panel h2, .megamenu-menu-panel h1, .long-btn { color: inherit; }
.megamenu-menu-panel input[type="text"] { background: inherit; border-width: 0px 0px 1px; border-top-style: initial; border-right-style: initial; border-left-style: initial; border-color: initial; border-image: initial; border-bottom-style: solid; }
#recent-file-panel-action-btn { background: inherit; border: 1px solid grey; }
.megamenu-menu-panel .dropdown-menu > li > a { color: inherit; background-color: rgb(47, 53, 58); text-decoration: none; }
.megamenu-menu-panel table td:nth-child(1) { color: inherit; font-weight: bold; }
.megamenu-menu-panel tbody tr:hover td:nth-child(1) { color: white; }
.modal-footer .btn-default, .modal-footer .btn-primary, .modal-footer .btn-default:not(:hover) { border: 1px solid transparent; }
.btn-default:hover, .btn-default:focus, .btn-default.focus, .btn-default:active, .btn-default.active, .open > .dropdown-toggle.btn-default { color: white; border: 1px solid rgb(221, 221, 221); background-color: inherit; }
.modal-header { border-bottom: 0px; }
.modal-footer { border-top: 0px; }
#recent-file-panel tbody tr:nth-child(2n-1) { background-color: transparent !important; }
.megamenu-menu-panel tbody tr:hover td:nth-child(2) { color: inherit; }
.megamenu-menu-panel .btn { border: 1px solid rgb(238, 238, 238); background: transparent; }
.mouse-hover .toolbar-icon.btn:hover, #w-full.mouse-hover, #w-pin.mouse-hover { background-color: inherit; }
.typora-node::-webkit-scrollbar { width: 5px; }
.typora-node::-webkit-scrollbar-thumb:vertical { background: rgba(250, 250, 250, 0.3); }
.typora-node::-webkit-scrollbar-thumb:vertical:active { background: rgba(250, 250, 250, 0.5); }
#w-unpin { background-color: rgb(65, 130, 196); }
#top-titlebar, #top-titlebar * { color: var(--item-hover-text-color); }
.typora-sourceview-on #toggle-sourceview-btn, #footer-word-count:hover, .ty-show-word-count #footer-word-count { background: rgb(51, 51, 51); }
#toggle-sourceview-btn:hover { color: rgb(238, 238, 238); background: rgb(51, 51, 51); }
.on-focus-mode .md-end-block:not(.md-focus):not(.md-focus-container) * { color: rgb(104, 104, 104) !important; }
.on-focus-mode .md-end-block:not(.md-focus) img, .on-focus-mode .md-task-list-item:not(.md-focus-container) > input { }
.on-focus-mode li[cid]:not(.md-focus-container) { color: rgb(104, 104, 104); }
.on-focus-mode .md-fences.md-focus .CodeMirror-code > :not(.CodeMirror-activeline) *, .on-focus-mode .CodeMirror.cm-s-inner:not(.CodeMirror-focused) * { color: rgb(104, 104, 104) !important; }
.on-focus-mode .md-focus, .on-focus-mode .md-focus-container { color: rgb(255, 255, 255); }
.on-focus-mode #typora-source .CodeMirror-code > :not(.CodeMirror-activeline) * { color: rgb(104, 104, 104) !important; }
#write .md-focus .md-diagram-panel { border: 1px solid rgb(221, 221, 221); margin-left: -1px; width: calc(100% + 2px); }
#write .md-focus.md-fences-with-lineno .md-diagram-panel { margin-left: auto; }
.md-diagram-panel-error { color: rgb(241, 144, 142); }
.active-tab-files #info-panel-tab-file, .active-tab-files #info-panel-tab-file:hover, .active-tab-outline #info-panel-tab-outline, .active-tab-outline #info-panel-tab-outline:hover { color: rgb(238, 238, 238); }
.sidebar-footer-item:hover, .footer-item:hover { background: inherit; color: white; }
.ty-side-sort-btn.active, .ty-side-sort-btn:hover, .selected-folder-menu-item a::after { color: white; }
#sidebar-files-menu { border: 1px solid; box-shadow: rgba(0, 0, 0, 0.79) 4px 4px 20px; background-color: var(--bg-color); }
.file-list-item { border-bottom: none; }
.file-list-item-summary { opacity: 1; }
.file-list-item.active:first-child { border-top: none; }
.file-node-background { height: 32px; }
.file-library-node.active > .file-node-content, .file-list-item.active { color: var(--active-file-text-color); }
.file-library-node.active > .file-node-background { background-color: var(--active-file-bg-color); }
.file-list-item.active { background-color: var(--active-file-bg-color); }
#ty-tooltip { background-color: black; color: rgb(238, 238, 238); }
.md-task-list-item > input { margin-left: -1.3em; margin-top: 0.3rem; -webkit-appearance: none; }
.md-mathjax-midline { background-color: rgb(87, 97, 107); border-bottom: none; }
footer.ty-footer { border-color: rgb(101, 101, 101); }





 .typora-export li, .typora-export p, .typora-export,  .footnote-line {white-space: normal;} 
</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><p><a href="#head"><button style="position: fixed;top:70%;right:0px;background-color:black;" >置<br>顶</button></a></p><p><a id="head"/></p><h1><a href="https://pppenger.github.io/">pppenger.github.io</a></h1><p>目录</p><div class='md-toc' mdtype='toc'><p class="md-toc-content"><span class="md-toc-item md-toc-h3" data-ref="n7"><a class="md-toc-inner" href="#header-n7">封装</a></span><span class="md-toc-item md-toc-h3" data-ref="n13"><a class="md-toc-inner" href="#header-n13">多态</a></span><span class="md-toc-item md-toc-h4" data-ref="n14"><a class="md-toc-inner" href="#header-n14">引用多态</a></span><span class="md-toc-item md-toc-h4" data-ref="n16"><a class="md-toc-inner" href="#header-n16">方法多态</a></span><span class="md-toc-item md-toc-h3" data-ref="n19"><a class="md-toc-inner" href="#header-n19">java访问修饰符</a></span><span class="md-toc-item md-toc-h3" data-ref="n53"><a class="md-toc-inner" href="#header-n53">数据类型</a></span><span class="md-toc-item md-toc-h3" data-ref="n120"><a class="md-toc-inner" href="#header-n120">位运算符</a></span><span class="md-toc-item md-toc-h3" data-ref="n165"><a class="md-toc-inner" href="#header-n165">逻辑运算符</a></span><span class="md-toc-item md-toc-h3" data-ref="n202"><a class="md-toc-inner" href="#header-n202">运算符优先级</a></span><span class="md-toc-item md-toc-h3" data-ref="n209"><a class="md-toc-inner" href="#header-n209">static</a></span><span class="md-toc-item md-toc-h4" data-ref="n210"><a class="md-toc-inner" href="#header-n210">Java 中的 static 使用之静态变量</a></span><span class="md-toc-item md-toc-h4" data-ref="n220"><a class="md-toc-inner" href="#header-n220">Java 中的 static 使用之静态方法</a></span><span class="md-toc-item md-toc-h4" data-ref="n237"><a class="md-toc-inner" href="#header-n237">Java 中的 static 使用之静态初始化块</a></span><span class="md-toc-item md-toc-h3" data-ref="n250"><a class="md-toc-inner" href="#header-n250">final关键字</a></span><span class="md-toc-item md-toc-h3" data-ref="n262"><a class="md-toc-inner" href="#header-n262">什么是 Java 中的内部类</a></span><span class="md-toc-item md-toc-h4" data-ref="n285"><a class="md-toc-inner" href="#header-n285">Java 中的成员内部类</a></span><span class="md-toc-item md-toc-h4" data-ref="n304"><a class="md-toc-inner" href="#header-n304">Java 中的静态内部类</a></span><span class="md-toc-item md-toc-h4" data-ref="n312"><a class="md-toc-inner" href="#header-n312">Java 中的方法内部类</a></span><span class="md-toc-item md-toc-h3" data-ref="n319"><a class="md-toc-inner" href="#header-n319">引用类型转换</a></span><span class="md-toc-item md-toc-h3" data-ref="n324"><a class="md-toc-inner" href="#header-n324">接口interface</a></span><span class="md-toc-item md-toc-h4" data-ref="n328"><a class="md-toc-inner" href="#header-n328">匿名内部类</a></span><span class="md-toc-item md-toc-h2" data-ref="n341"><a class="md-toc-inner" href="#header-n341">Java API 简介</a></span><span class="md-toc-item md-toc-h2" data-ref="n346"><a class="md-toc-inner" href="#header-n346">java.lang 包</a></span><span class="md-toc-item md-toc-h3" data-ref="n375"><a class="md-toc-inner" href="#header-n375">一、String</a></span><span class="md-toc-item md-toc-h4" data-ref="n378"><a class="md-toc-inner" href="#header-n378">0.java中String new和直接赋值的区别</a></span><span class="md-toc-item md-toc-h4" data-ref="n407"><a class="md-toc-inner" href="#header-n407">1.Java 中 String 类的常用方法 Ⅰ</a></span><span class="md-toc-item md-toc-h4" data-ref="n421"><a class="md-toc-inner" href="#header-n421">2.Java 中的 String 类常用方法 Ⅱ</a></span><span class="md-toc-item md-toc-h4" data-ref="n429"><a class="md-toc-inner" href="#header-n429">3.java中字符串和字符数组的转换？</a></span><span class="md-toc-item md-toc-h4" data-ref="n432"><a class="md-toc-inner" href="#header-n432">4.StringBuilder 和StringBuffer</a></span><span class="md-toc-item md-toc-h5" data-ref="n435"><a class="md-toc-inner" href="#header-n435">StringBuffer</a></span><span class="md-toc-item md-toc-h5" data-ref="n492"><a class="md-toc-inner" href="#header-n492">StringBuilder </a></span><span class="md-toc-item md-toc-h3" data-ref="n501"><a class="md-toc-inner" href="#header-n501">Java 中基本类型和字符串之间的转换</a></span><span class="md-toc-item md-toc-h4" data-ref="n515"><a class="md-toc-inner" href="#header-n515">valueOf与parseInt方法</a></span><span class="md-toc-item md-toc-h3" data-ref="n524"><a class="md-toc-inner" href="#header-n524">二、包装类</a></span><span class="md-toc-item md-toc-h4" data-ref="n525"><a class="md-toc-inner" href="#header-n525">1.Integer 类</a></span><span class="md-toc-item md-toc-h4" data-ref="n581"><a class="md-toc-inner" href="#header-n581">2.Character 类</a></span><span class="md-toc-item md-toc-h4" data-ref="n613"><a class="md-toc-inner" href="#header-n613">3.Boolean 类</a></span><span class="md-toc-item md-toc-h3" data-ref="n648"><a class="md-toc-inner" href="#header-n648">三、Math</a></span><span class="md-toc-item md-toc-h3" data-ref="n715"><a class="md-toc-inner" href="#header-n715">四、类 Class</a></span><span class="md-toc-item md-toc-h3" data-ref="n727"><a class="md-toc-inner" href="#header-n727">五、Object类</a></span><span class="md-toc-item md-toc-h4" data-ref="n753"><a class="md-toc-inner" href="#header-n753">toString()方法</a></span><span class="md-toc-item md-toc-h4" data-ref="n756"><a class="md-toc-inner" href="#header-n756">equals和==的区别</a></span><span class="md-toc-item md-toc-h2" data-ref="n763"><a class="md-toc-inner" href="#header-n763">java日期和随机数</a></span><span class="md-toc-item md-toc-h3" data-ref="n765"><a class="md-toc-inner" href="#header-n765">一、java.util 和 java.time 包介绍</a></span><span class="md-toc-item md-toc-h3" data-ref="n770"><a class="md-toc-inner" href="#header-n770">二、Date 类和Calendar 类</a></span><span class="md-toc-item md-toc-h3" data-ref="n794"><a class="md-toc-inner" href="#header-n794">三、java.time 包</a></span><span class="md-toc-item md-toc-h3" data-ref="n802"><a class="md-toc-inner" href="#header-n802">四、Random 类</a></span><span class="md-toc-item md-toc-h2" data-ref="n826"><a class="md-toc-inner" href="#header-n826">Java 集合框架</a></span><span class="md-toc-item md-toc-h3" data-ref="n830"><a class="md-toc-inner" href="#header-n830">一、Collection 接口</a></span><span class="md-toc-item md-toc-h3" data-ref="n897"><a class="md-toc-inner" href="#header-n897">二、Map接口</a></span><span class="md-toc-item md-toc-h3" data-ref="n962"><a class="md-toc-inner" href="#header-n962">三、List 接口与 ArrayList 类</a></span><span class="md-toc-item md-toc-h3" data-ref="n1020"><a class="md-toc-inner" href="#header-n1020">四、Set 接口和 HashSet 类</a></span><span class="md-toc-item md-toc-h3" data-ref="n1026"><a class="md-toc-inner" href="#header-n1026">五、HashSet和HashMap的区别</a></span><span class="md-toc-item md-toc-h3" data-ref="n1047"><a class="md-toc-inner" href="#header-n1047">六、HashMap 类</a></span><span class="md-toc-item md-toc-h3" data-ref="n1052"><a class="md-toc-inner" href="#header-n1052">七、结合Util工具包</a></span><span class="md-toc-item md-toc-h2" data-ref="n1059"><a class="md-toc-inner" href="#header-n1059">Java io</a></span><span class="md-toc-item md-toc-h3" data-ref="n1066"><a class="md-toc-inner" href="#header-n1066">一、字节流</a></span><span class="md-toc-item md-toc-h4" data-ref="n1067"><a class="md-toc-inner" href="#header-n1067">1、基类：InputStream 和 OutputStream</a></span><span class="md-toc-item md-toc-h4" data-ref="n1103"><a class="md-toc-inner" href="#header-n1103">2、文件流</a></span><span class="md-toc-item md-toc-h4" data-ref="n1118"><a class="md-toc-inner" href="#header-n1118">3、缓冲流（速度快）</a></span><span class="md-toc-item md-toc-h4" data-ref="n1128"><a class="md-toc-inner" href="#header-n1128">4、 数据流</a></span><span class="md-toc-item md-toc-h4" data-ref="n1139"><a class="md-toc-inner" href="#header-n1139">5、标准流、内存读写流、顺序输入流</a></span><span class="md-toc-item md-toc-h3" data-ref="n1155"><a class="md-toc-inner" href="#header-n1155">二、字符流</a></span><span class="md-toc-item md-toc-h4" data-ref="n1156"><a class="md-toc-inner" href="#header-n1156">1、基类：Reader 和 Writer</a></span><span class="md-toc-item md-toc-h4" data-ref="n1215"><a class="md-toc-inner" href="#header-n1215">2、InputStreamReader 和 OutputStreamWriter</a></span><span class="md-toc-item md-toc-h4" data-ref="n1221"><a class="md-toc-inner" href="#header-n1221">3、缓存流</a></span><span class="md-toc-item md-toc-h4" data-ref="n1230"><a class="md-toc-inner" href="#header-n1230">4、其它字符流类</a></span><span class="md-toc-item md-toc-h3" data-ref="n1249"><a class="md-toc-inner" href="#header-n1249">三、File文件操作</a></span><span class="md-toc-item md-toc-h3" data-ref="n1257"><a class="md-toc-inner" href="#header-n1257">四、RandomAccessFile类</a></span></p></div><p>&nbsp;</p><h3><a name='header-n7' class='md-header-anchor '></a>封装</h3><p>1.概念：将类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问</p><p>2.好处：</p><p>a.只能通过规定的方法访问数据</p><p>b.隐藏类的实例细节，方便修改和实现</p><p>&nbsp;</p><h3><a name='header-n13' class='md-header-anchor '></a>多态</h3><h4><a name='header-n14' class='md-header-anchor '></a>引用多态</h4><p>父类的引用可以指向本类的对象
父类的引用可以指向子类的对象</p><h4><a name='header-n16' class='md-header-anchor '></a>方法多态</h4><p>创建本类对象时，调用的方法为本类方法
创建子类对象时，调用的方法为之类重写的方法或者继承的方法</p><p>&nbsp;</p><h3><a name='header-n19' class='md-header-anchor '></a>java访问修饰符</h3><figure><table><thead><tr><th>访问修饰符</th><th>本类</th><th>同包</th><th>子类</th><th>其他</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>默认</td><td>√</td><td>√</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>&nbsp;</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n53' class='md-header-anchor '></a>数据类型</h3><p>Java 中一共八种基本数据类型，下表列出了基本数据类型的数据范围、存储格式、默认值、包装类型等。</p><figure><table><thead><tr><th>数据类型</th><th>默认值</th><th>存储格式</th><th>数据范围</th><th>包装类型</th></tr></thead><tbody><tr><td>short</td><td>0</td><td>2 个字节</td><td>-32,768 到 32767</td><td>Short</td></tr><tr><td>int</td><td>0</td><td>4 个字节</td><td>-2,147,483,648 到 2,147,483,647</td><td>Integer</td></tr><tr><td>byte</td><td>0</td><td>1 个字节</td><td>-128 到 127</td><td>Byte</td></tr><tr><td>char</td><td>空</td><td>2 个字节</td><td>Unicode 的字符范围：’\u0000’（即为 0）到’\uffff’（即为 65,535）</td><td>Character</td></tr><tr><td>long</td><td>0L 或 0l</td><td>8 个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036, 854,775,807</td><td>Long</td></tr><tr><td>float</td><td>0.0F 或 0.0f</td><td>4 个字节</td><td>32 位 IEEEE-754 单精度范围</td><td>Float</td></tr><tr><td>double</td><td>0.0 或 0.0D(d)</td><td>8 个字节</td><td>64 位 IEEE-754 双精度范围</td><td>Double</td></tr><tr><td>boolean</td><td>false</td><td>1 位</td><td>true 或 false</td><td>Boolean</td></tr></tbody></table></figure><p><strong>整数</strong></p><p>byte、short、int、long 四种基本数据类型表示整数，需要注意的是 long 类型，使用 long 修饰的变量需要在数值后面加上 L 或者 l，比如<code>long num=1L;</code>，一般使用大写 L，为了避免小写 l 与数值 1 混淆。</p><p><strong>浮点数</strong></p><p>float 和 double 类型表示浮点数，即可以表示小数部分。需要注意的是 float 类型的数值后面需要加上 F 或者 f，否则会被当成 double 类型处理。double 类型的数值可以加上 D 或 d，也可以不加。</p><p><strong>char</strong> <strong>类型</strong></p><p>char 类型用于表示单个字符。需要将字符用单引号括起来<code>char a=&#39;a&#39;</code>，char 可以和整数互相转换，如果字符<code>a</code>也可以写成<code>char a=97</code>。也可以用十六进制表示<code>char a = &#39;\u0061&#39;</code>。</p><p><strong>boolean</strong> <strong>类型</strong></p><p>boolean 类型（布尔类型）用于表示真值<code>true</code>或者假值<code>false</code>，Java 中布尔值不能和整数类型或者其它类型互相转换。</p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n120' class='md-header-anchor '></a>位运算符</h3><p>Java 定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。位运算时先转换为二进制，再按位运算。</p><p>表格中的例子中，变量<code>a</code>的值为 60(00111100)，变量<code>b</code>(00001101)的值为 13：</p><figure><table><thead><tr><th>位运算符</th><th>名称</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td><td>如果相对应位都是 1，则结果为 1，否则为 0</td><td>（a＆b），得到 12，即 0000 1100</td></tr><tr><td>丨</td><td>按位或</td><td>如果相对应位都是 0，则结果为 0，否则为 1</td><td>（ a 丨 b ）得到 61，即 0011 1101</td></tr><tr><td>^</td><td>按位异或</td><td>如果相对应位值相同，则结果为 0，否则为 1</td><td>（a^b）得到 49，即 0011 0001</td></tr><tr><td>~</td><td>按位补</td><td>翻转操作数的每一位，即 0 变成 1，1 变成 0</td><td>（〜a）得到-61，即 1100 0011</td></tr><tr><td>&lt;&lt;</td><td>按位左移</td><td>左操作数按位左移右操作数指定的位数</td><td>a&lt;&lt;2 得到 240，即 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>按位右移</td><td>左操作数按位右移右操作数指定的位数</td><td>a&gt;&gt;2 得到 15 即 1111</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零</td><td>左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充</td><td>a&gt;&gt;&gt;2 得到 15 即 0000 1111</td></tr></tbody></table></figure><p>&nbsp;</p><h3><a name='header-n165' class='md-header-anchor '></a>逻辑运算符</h3><p>逻辑运算符是通过运算符将操作数或等式进行逻辑判断的语句。</p><p>表格中的例子中，假设布尔变量 a 为真，变量 b 为假：</p><figure><table><thead><tr><th>逻辑运算符</th><th>名称</th><th>描述</th><th>类型</th><th>举例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与</td><td>当且仅当两个操作数都为真，条件才为真</td><td>双目运算符</td><td>（a &amp;&amp; b）为假</td></tr><tr><td>｜｜</td><td>或</td><td>两个操作数任何一个为真，条件为真</td><td>双目运算符</td><td>（a ｜｜ b）为真</td></tr><tr><td>！</td><td>非</td><td>用来反转操作数的逻辑状态。如果条件为真，则逻辑非运算符将得到假</td><td>单目运算符</td><td>（!a）为假</td></tr><tr><td>^</td><td>异或</td><td>如果两个操作数逻辑相同，则结果为假，否则为真</td><td>双目运算符</td><td>（a ^ b）为真</td></tr></tbody></table></figure><p><strong>当使用<code>&amp;&amp;(与)</code>逻辑运算符时，在两个操作数都为 true 时，结果才为 true，但是当得到第一个操作为 false 时，其结果就必定是 false，这时候就不会再判断第二个操作了。</strong> </p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n202' class='md-header-anchor '></a>运算符优先级</h3><p>运算符的优先级是帮助我们在一个表达式中如何对于不同的运算符和相同的运算符，进行正确的运算顺序。</p><p>运算符的优先级不需要特别地去记忆它，比较复杂的表达式一般使用圆括号<code>()</code>分开，提高可读性。</p><p>!<img src='https://doc.shiyanlou.com/document-uid79144labid1050timestamp1434082078141.png/wm' alt='运算符的优先级' referrerPolicy='no-referrer' /></p><p><img src='https://doc.shiyanlou.com/document-uid79144labid1050timestamp1434082102195.png/wm' alt='运算符的优先级2' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n209' class='md-header-anchor '></a>static</h3><h4><a name='header-n210' class='md-header-anchor '></a>Java 中的 static 使用之静态变量</h4><p><font size=3>Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。当然，鉴于他作用的特殊性更推荐用类名访问~~</font></p><p>使用 static 可以修饰变量、方法和代码块。</p><p>例如，我们在类中定义了一个 静态变量 hobby ，操作代码如下所示：</p><p><a href='http://img.mukewang.com/5392d47b0001571708530473.jpg'><img src='http://img.mukewang.com/5392d47b0001571708530473.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果：<a href='http://img.mukewang.com/5392d4a4000133c002950084.jpg'><img src='http://img.mukewang.com/5392d4a4000133c002950084.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p><strong>注意：</strong>静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收！~~</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n220' class='md-header-anchor '></a>Java 中的 static 使用之静态方法</h4><p>与静态变量一样，我们也可以使用 static 修饰方法，称为静态方法或类方法。其实之前我们一直写的 main 方法就是静态方法。静态方法的使用如：</p><p><a href='http://img.mukewang.com/539137150001c96c08220542.jpg'><img src='http://img.mukewang.com/539137150001c96c08220542.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果：<a href='http://img.mukewang.com/5391358100013f8502330076.jpg'><img src='http://img.mukewang.com/5391358100013f8502330076.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>需要注意：</p><p>1、 <strong>静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。</strong>如：</p><p><a href='http://img.mukewang.com/5392d6eb0001283007020239.jpg'><img src='http://img.mukewang.com/5392d6eb0001283007020239.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p><strong>如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量</strong>。如：</p><p><a href='http://img.mukewang.com/5392d7390001a10806150193.jpg'><img src='http://img.mukewang.com/5392d7390001a10806150193.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>2、 <strong>在普通成员方法中，则可以直接访问同类的非静态变量和静态变量</strong>，如下所示：</p><p><a href='http://img.mukewang.com/5392d78e000155c305470193.jpg'><img src='http://img.mukewang.com/5392d78e000155c305470193.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>3、 <strong>静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。</strong>如：</p><p><a href='http://img.mukewang.com/53a3fb160001d04a04910345.jpg'><img src='http://img.mukewang.com/53a3fb160001d04a04910345.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n237' class='md-header-anchor '></a>Java 中的 static 使用之静态初始化块</h4><p>Java 中可以通过初始化块进行数据赋值。如：</p><p><a href='http://img.mukewang.com/5392da9600010e5503680168.jpg'><img src='http://img.mukewang.com/5392da9600010e5503680168.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>在类的声明中，可以包含多个初始化块，当创建类的实例时，就会依次执行这些代码块。如果使用 static 修饰初始化块，就称为静态初始化块。</p><p>需要特别注意：<strong>静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量</strong>。</p><p>我们来看一段代码：</p><p><a href='http://img.mukewang.com/53941e320001fdd507670575.jpg'><img src='http://img.mukewang.com/53941e320001fdd507670575.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果：</p><p><a href='http://img.mukewang.com/53941e880001cb8003530223.jpg'><img src='http://img.mukewang.com/53941e880001cb8003530223.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>通过输出结果，我们可以看到，程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法。由于静态初始化块只在类加载时执行一次，所以当再次创建对象 hello2 时并未执行静态初始化块。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n250' class='md-header-anchor '></a>final关键字</h3><p>final可以修饰类、方法、属性和变量</p><p>final修饰类，则该类不允许被继承</p><p>final修饰方法，则改方法不允许被覆盖(重写)</p><p>final修饰属性</p><p><span>		</span>则该类的属性不可修改且不会进行隐式自动初始化</p><p><span>		</span>或在构造方法中赋值（只能选其一）</p><p>final修饰变量，变量不可修改，只能赋值一次，即变为常量</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n262' class='md-header-anchor '></a>什么是 Java 中的内部类</h3><p><strong>问：什么是内部类呢？</strong></p><p>答：内部类（ Inner Class ）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类。</p><p><strong>问：那为什么要将一个类定义在另一个类里面呢？清清爽爽的独立的一个类多好啊！！</strong></p><p>答：内部类的主要作用如下：</p><ol start='' ><li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类</li><li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据</li><li>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便</li></ol><p><strong>问：内部类有几种呢？</strong></p><p>答：内部类可分为以下几种：</p><ul><li>成员内部类</li><li>静态内部类</li><li>方法内部类</li><li>匿名内部类</li></ul><h4><a name='header-n285' class='md-header-anchor '></a>Java 中的成员内部类</h4><p>内部类中最常见的就是成员内部类，也称为普通内部类。我们来看如下代码：</p><p><a href='http://img.mukewang.com/539e60d80001223908320512.jpg'><img src='http://img.mukewang.com/539e60d80001223908320512.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果为：<a href='http://img.mukewang.com/539e60f70001b89302170050.jpg'><img src='http://img.mukewang.com/539e60f70001b89302170050.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>从上面的代码中我们可以看到，<strong>成员内部类的使用方法</strong>：</p><p>1、 Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public 、 protected 、 private 等</p><p>2、 Inner 类中定义的 test() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性a</p><p>3、 定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 = 外部类对象.new 内部类( );</p><p>4、 编译上面的程序后，会发现产生了两个 .class 文件</p><p><a href='http://img.mukewang.com/53a004590001164004560040.jpg'><img src='http://img.mukewang.com/53a004590001164004560040.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>其中，第二个是外部类的 .class 文件，第一个是内部类的 .class 文件，即成员内部类的 .class 文件总是这样：外部类名$内部类名.class</p><p>另外，<strong>友情提示哦：</strong></p><p>1、 外部类是不能直接使用内部类的成员和方法滴</p><p><a href='http://img.mukewang.com/54641b6300012da606460299.jpg'><img src='http://img.mukewang.com/54641b6300012da606460299.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。</p><p>2、 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字。如：</p><p><a href='http://img.mukewang.com/539e638b0001ab1208200295.jpg'><img src='http://img.mukewang.com/539e638b0001ab1208200295.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果：<a href='http://img.mukewang.com/539e63d400016cf101960050.jpg'><img src='http://img.mukewang.com/539e63d400016cf101960050.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>&nbsp;</p><h4><a name='header-n304' class='md-header-anchor '></a>Java 中的静态内部类</h4><p>静态内部类是 static 修饰的内部类，这种内部类的特点是：</p><p>1、 静态内部类不能直接访问外部类的非静态成员，但可以通过 <strong>new 外部类().成员</strong> 的方式访问 </p><p>2、 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员</p><p>3、 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 <strong>内部类 对象名= new 内部类();</strong></p><p><a href='http://img.mukewang.com/539e948a0001a71007630511.jpg'><img src='http://img.mukewang.com/539e948a0001a71007630511.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果 ： <a href='http://img.mukewang.com/539e94a500014f0101930052.jpg'><img src='http://img.mukewang.com/539e94a500014f0101930052.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>&nbsp;</p><h4><a name='header-n312' class='md-header-anchor '></a>Java 中的方法内部类</h4><p>方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。</p><p><a href='http://img.mukewang.com/539ea96700013ca708200621.jpg'><img src='http://img.mukewang.com/539ea96700013ca708200621.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p><strong>一定要注意哦：</strong>由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n319' class='md-header-anchor '></a>引用类型转换</h3><p>1.向上类型转换（隐式/自动类型转换），是小类型到大类型的转换</p><p>2.向下类型转换（强制类型转换），是大类型到小类型</p><p>3.instanceof运算符（判断前面是否包含后面），来解决引用对象的类型，避免类型转换的安全性问题</p><p>&nbsp;</p><h3><a name='header-n324' class='md-header-anchor '></a>接口interface</h3><p>必选加sbstract关键字，默认有加</p><p><strong>接口可以多继承父类，但类只能单继承</strong>
<strong>一个类可以实现一个或多个接口</strong></p><p>常量：接口中的属性是常量，即使定义时不添加public static final修饰符，系统也会自动加上
方法：只能是抽象方法，不加public static修饰符，系统也会自动加上</p><h4><a name='header-n328' class='md-header-anchor '></a>匿名内部类</h4><p>没有名字的内部类，一般不关注类的名称只关注实现</p><p>语法：</p><p><code>Interface i=new Interface(){</code></p><p><code>public void method(){...};</code></p><p><code>}</code></p><p><code>i.method</code></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n341' class='md-header-anchor '></a>Java API 简介</h2><p>Java 的核心 API 是非常庞大的，这给开发者来说带来了很大的方便。所谓的 API 就是一些已经写好、可直接调用的类库。Java 里有非常庞大的 API，其中有一些类库是我们必须得掌握的，只有熟练掌握了 Java 一些核心的 API，我们才能更好的使用 Java。</p><p><img src='https://doc.shiyanlou.com/document-uid18510labid1118timestamp1500451929664.png/wm' alt='img' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n346' class='md-header-anchor '></a>java.lang 包</h2><figure><table><thead><tr><th>原始数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte（字节）</td><td>Byte</td></tr><tr><td>char（字符）</td><td>Character</td></tr><tr><td>int（整型）</td><td>Integer</td></tr><tr><td>long （长整型）</td><td>Long</td></tr><tr><td>float（浮点型）</td><td>Float</td></tr><tr><td>double （双精度）</td><td>Double</td></tr><tr><td>boolean （布尔）</td><td>Boolean</td></tr><tr><td>short（短整型）</td><td>Short</td></tr></tbody></table></figure><h3><a name='header-n375' class='md-header-anchor '></a>一、String</h3><p><strong>String 对象创建后则不能被修改</strong>，是不可变的，所谓的修改其实是创建了新的对象，所指向的内存空间不同。</p><p>&nbsp;</p><h4><a name='header-n378' class='md-header-anchor '></a>0.java中String new和直接赋值的区别</h4><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">对于字符串：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 78px;"></div><div class="CodeMirror-gutters" style="display: none; height: 78px;"></div></div></div></pre><p>例如：</p><p>String str1=&quot;ABC&quot;； 和String str2 = new String(&quot;ABC&quot;); </p><p><strong>String str1=&quot;ABC&quot; 可能创建一个对象或者不创建对象</strong>，如果&quot;ABC&quot;这个字符串在java String池里不存在，会在java String池创建这个一个String对象(&quot;ABC&quot;).如果已经存在，str1直接reference to 这个String池里的对象。</p><p><strong>String str2 = new String(&quot;ABC&quot;) 至少创建一个对象，也可能两个。</strong>因为用到new 关键字，会在heap创建一个 str2 的String 对象，它的value 是 &quot;ABC&quot;.同时，如果&quot;ABC&quot;这个字符串在java String池里不存在，会在java String池创建这个一个String对象(&quot;ABC&quot;).</p><p>String 有一个<strong>intern()</strong> 方法，native，用来检测在String pool是否已经有这个String存在。</p><p>&nbsp;</p><p>考虑下面的问题：</p><p>String str1 = new String(&quot;ABC&quot;);
String str2 = new String(&quot;ABC&quot;);</p><p>str1 == str2 的值是True 还是False呢？ False.</p><p>String str3 = &quot;ABC&quot;;
String str4 = &quot;ABC&quot;;</p><p>String str5 = &quot;A&quot; + &quot;BC&quot;;</p><p>str3 == str4 的值是True 还是False呢？ True.</p><p>str3 == str5 的值是True 还是False呢？ True.</p><p>String a = &quot;ABC&quot;;
String b=&quot;AB&quot;;
String c=b+&quot;C&quot;;
System.out.println(a==c); false
a和b都是字符串常量所以在编译期就被确定了！</p><p>而c中有个b是引用不是字符串常量所以不会在编译期确定。
而String是final的！所以在b+&quot;c&quot;的时候实际上是新创建了一个对象，然后在把新创建对象的引用传给c.</p><p>&nbsp;</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public static void main(String[] args) throws Exception { &nbsp;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String a =  "b" ; &nbsp; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String b =  "b" ; &nbsp; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( a == b); &nbsp; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String d = new String( "d" ).intern() ; //jdk6复制副本但还是指向堆内存，jdk6+复制了后把引用也指过去了</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String c = "d" ; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( c == d);  //jdk6及以前为false，jdk6+为true</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println("------------------"); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String d1 = new String( "d" ) ; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String e1=d1.intern();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String c1 = "d" ; &nbsp; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( c1 == d1); &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( c1 == e1); &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( e1 == d1); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println("------------------"); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String s1=new String("kvill"); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String s2=s1.intern(); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( s1==s2 ); //s1=s1.intern()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( s1+" "+s2 ); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( s2==s1.intern() ); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">} &nbsp;</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 572px;"></div><div class="CodeMirror-gutters" style="display: none; height: 572px;"></div></div></div></pre><p>运行结果：
true
true
false
true
false
false
kvill kvill
true</p><p>s1==s1.intern()为false说明原来的“kvill”仍然存在； </p><p>例子代码：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String s1 = "china"; </span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String s2 = "china";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String s3 = "china"; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String ss1 = new String("china"); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String ss2 = new String("china"); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String ss3 = new String("china"); &nbsp; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  这里解释一下，对于通过 new 产生一个字符串（假设为 ”china” ）时，会先去常量池中查找是否已经有了 ”china” 对象，如果没有则在常量池中创建一个此字符串对象，然后堆中再创建一个常量池中此 ”china” 对象的拷贝对象。</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 260px;"></div><div class="CodeMirror-gutters" style="display: none; height: 260px;"></div></div></div></pre><p><strong>也就是有道面试题： String s = new String(“xyz”); 产生几个对象？</strong></p><p><strong>一个或两个。如果常量池中原来没有 ”xyz”, 就是两个。如果原来的常量池中存在“xyz”时，就是一个。</strong></p><p>对于基础类型的变量和常量：变量和引用存储在栈中，常量存储在常量池中。</p><p>应用的情况：建议在平时的使用中，尽量使用String = “abcd”;这种方式来创建字符串，而不是String = new String(“abcd”);这种形式，因为使用new构造器创建字符串对象一定会开辟一个新的heap（堆）空间，而双引号则是采用了String interning(字符串驻留)进行了优化，效率比构造器高。</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n407' class='md-header-anchor '></a>1.Java 中 String 类的常用方法 Ⅰ</h4><p>String 类提供了许多用来处理字符串的方法，例如，获取字符串长度、对字符串进行截取、将字符串转换为大写或小写、字符串分割等，下面我们就来领略它的强大之处吧。</p><p>String 类的常用方法：</p><p><a href='http://img.mukewang.com/53d9f7d200010bb007780366.jpg'><img src='http://img.mukewang.com/53d9f7d200010bb007780366.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">`equalsIgnoreCase()`方法，其用法与 equals 一致，不过它会忽视大小写。</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">字符串连接有两种方法：</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">1.使用`+`，比如`String s = "Hello " + "World!"`使用`+`进行连接，不仅可以连接字符串，也可以连接其他类型。但是要求进行连接时至少有一个参与连接的内容是字符串类型。</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">2.使用 String 类的 concat() 方法</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 182px;"></div><div class="CodeMirror-gutters" style="display: none; height: 182px;"></div></div></div></pre><p>结合代码来熟悉一下方法的使用：（JAVA前后有两个空格）</p><p><a href='http://img.mukewang.com/53a8e7320001a8d807090391.jpg'><img src='http://img.mukewang.com/53a8e7320001a8d807090391.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果：</p><p><a href='http://img.mukewang.com/53a8e74e00011f5703850166.jpg'><img src='http://img.mukewang.com/53a8e74e00011f5703850166.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p><strong>友情提示：</strong></p><p>\1. 字符串 str 中字符的索引从0开始，范围为 0 到 str.length()-1</p><p>\2. 使用 indexOf 进行字符或字符串查找时，如果匹配返回位置索引；如果没有匹配结果，返回 -1</p><p>\3. 使用 substring(beginIndex , endIndex) 进行字符串截取时，包括 beginIndex 位置的字符，不包括 endIndex 位置的字符</p><p>&nbsp;</p><h4><a name='header-n421' class='md-header-anchor '></a>2.Java 中的 String 类常用方法 Ⅱ</h4><p>我们继续来看 String 类常用的方法，如下代码所示：</p><p><a href='http://img.mukewang.com/53a9260b0001808e06540410.jpg'><img src='http://img.mukewang.com/53a9260b0001808e06540410.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果：</p><p><a href='http://img.mukewang.com/53a9239300017e1c07910137.jpg'><img src='http://img.mukewang.com/53a9239300017e1c07910137.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>那么，“==” 和 equals() 有什么区别呢？
==: 判断两个字符串在内存中首地址是否相同，即判断是否是同一个字符串对象
equals(): 比较存储在两个字符串对象中的内容是否一致</p><p>PS：字节是计算机存储信息的基本单位，1 个字节等于 8 位， gbk 编码中 1 个汉字字符存储需要 2 个字节，1 个英文字符存储需要 1 个字节。所以我们看到上面的程序运行结果中，每个汉字对应两个字节值，如“学”对应 “-47 -89” ，而英文字母 “J” 对应 “74” 。同时，我们还发现汉字对应的字节值为负数，原因在于每个字节是 8 位，最大值不能超过 127，而汉字转换为字节后超过 127，如果超过就会溢出，以负数的形式显示。</p><p>&nbsp;</p><h4><a name='header-n429' class='md-header-anchor '></a>3.java中字符串和字符数组的转换？</h4><p>1、字符串是类，字符数组是数组。
2、字符数组是char类型的，字符串是String类型的
3、两者之间的相互转化：
String s=&quot;this is a string&quot;;
char[ ] c={&#39;t&#39;,&#39;h&#39;,&#39;i&#39;,&#39;s&#39;,&#39;i&#39;,&#39;s&#39;,&#39;a&#39;,&#39;c&#39;,&#39;h&#39;,&#39;a&#39;,&#39;r&#39;};
字符串转换为字符数组
char[ ] ch=s.toCharArray();
字符数组转化为字符串
String str=string.valueOf(c);  </p><p>&nbsp;</p><h4><a name='header-n432' class='md-header-anchor '></a>4.StringBuilder 和StringBuffer</h4><p>当频繁操作字符串时，就会额外产生很多临时变量。使用 StringBuilder 或 StringBuffer 就可以避免这个问题。至于 StringBuilder 和StringBuffer ，它们基本相似，不同之处，<strong>StringBuffer 是线程安全的，而 StringBuilder 则没有实现线程安全功能</strong>，所以性能略高。因此一般情况下，如果需要创建一个内容可变的字符串对象，应优先考虑使用 StringBuilder 类。</p><p>&nbsp;</p><h5><a name='header-n435' class='md-header-anchor '></a>StringBuffer</h5><figure><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>StringBuffer()</td><td>构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符</td></tr><tr><td>StringBuffer(CharSequence seq)</td><td>构造一个字符串缓冲区，它包含与指定的 CharSequence 相同的字符</td></tr><tr><td>StringBuffer(int capacity)</td><td>构造一个不带字符，但具有指定初始容量的字符串缓冲区</td></tr><tr><td>StringBuffer(String str)</td><td>构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容</td></tr></tbody></table></figure><p>StringBuffer 类的常用方法：</p><figure><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>insert(int offsetm,Object s)</td><td>StringBuffer</td><td>在 offsetm 的位置插入字符串 s</td></tr><tr><td>append(Object s)</td><td>StringBuffer</td><td>在字符串末尾追加字符串 s</td></tr><tr><td>length()</td><td>int</td><td>确定 StringBuffer 对象的长度</td></tr><tr><td>setCharAt(int pos,char ch)</td><td>void</td><td>使用 ch 指定的新值设置 pos 指定的位置上的字符</td></tr><tr><td>toString()</td><td>String</td><td>转换为字符串形式</td></tr><tr><td>reverse()</td><td>StringBuffer</td><td>反转字符串</td></tr><tr><td>delete(int start, int end)</td><td>StringBuffer</td><td>删除调用对象中从 start 位置开始直到 end 指定的索引（end-1）位置的字符序列</td></tr><tr><td>replace(int start, int end, String s)</td><td>StringBuffer</td><td>使用一组字符替换另一组字符。将用替换字符串从 start 指定的位置开始替换，直到 end 指定的位置结束</td></tr></tbody></table></figure><p>&nbsp;</p><p>&nbsp;</p><h5><a name='header-n492' class='md-header-anchor '></a>StringBuilder </h5><p>StringBuilder 类提供了很多方法来操作字符串：</p><p><a href='http://img.mukewang.com/53a7d34300011c6005970125.jpg'><img src='http://img.mukewang.com/53a7d34300011c6005970125.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>例如：在下面的示例代码中，创建了 StringBuilder 对象，用来存储字符串，并对其做了追加和插入操作。这些操作修改了 str 对象的值，而没有创建新的对象，这就是 StringBuilder 和 String 最大的区别。</p><p><a href='http://img.mukewang.com/53a7d36c0001e3cd06760242.jpg'><img src='http://img.mukewang.com/53a7d36c0001e3cd06760242.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果： <a href='http://img.mukewang.com/53a7d3ab0001ff3803060080.jpg'><img src='http://img.mukewang.com/53a7d3ab0001ff3803060080.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n501' class='md-header-anchor '></a>Java 中基本类型和字符串之间的转换</h3><p>在程序开发中，我们经常需要在基本数据类型和字符串之间进行转换。</p><p>其中，基本类型转换为字符串有三种方法：</p><p>\1. 使用包装类的 toString() 方法</p><p>\2. 使用String类的 valueOf() 方法</p><p>\3. 用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串</p><p><a href='http://img.mukewang.com/53abea61000151e105120118.jpg'><img src='http://img.mukewang.com/53abea61000151e105120118.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>再来看，将字符串转换成基本类型有两种方法：</p><p>\1. 调用包装类的 parseXxx 静态方法</p><p>\2. 调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱</p><p><a href='http://img.mukewang.com/53abeaad000109af04610098.jpg'><img src='http://img.mukewang.com/53abeaad000109af04610098.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n515' class='md-header-anchor '></a>valueOf与parseInt方法</h4><p><strong>首先从返回类型可以看出parseInt返回的是基本类型int，而valueOf返回的是对象（可自动拆装箱）。</strong></p><p>源码：</p><p><code>public static Integer valueOf(String s) throws NumberFormatException {</code>
        <code>return Integer.valueOf(parseInt(s, 10));</code>
 <code>}</code></p><p> <code>public static Integer valueOf(int i) {</code>
    <code>assert IntegerCache.high &gt;= 127;</code>
 <span>	</span><code>if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</code>
        <code>return IntegerCache.cache[i + (-IntegerCache.low)];</code>
    <code>return new Integer(i);</code>
 <code>}</code></p><p> <code>public static int parseInt(String s) throws NumberFormatException {</code>
    <span>	</span><code>return parseInt(s,10);</code>
 <code>}</code></p><p>因为JDK5以后实现了自动拆装箱，因而两者的差别也不是特别大了，但是从效率上考虑，建议首先考虑parseInt方法。</p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n524' class='md-header-anchor '></a>二、包装类</h3><h4><a name='header-n525' class='md-header-anchor '></a>1.Integer 类</h4><p>java.lang 包中的 Integer 类、Long 类和 Short 类都是 Number 的子类，他们的区别在于不同子类里面封装着不同的数据类型，比如 Integer 类包装了一个基本类型 int。其包含的方法基本相同。</p><figure><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>byteValue()</td><td>byte</td><td>以 byte 类型返回该 Integer 的值</td></tr><tr><td>compareTo(Integer anotherInteger)</td><td>int</td><td>在数字上比较 Integer 对象。如果这两个值相等，则返回 0；如果调用对象的数值小于 anotherInteger 的数值，则返回负值；如果调用对象的数值大于 anotherInteger 的数值，则返回正值</td></tr><tr><td>equals(Object IntegerObj)</td><td>boolean</td><td>比较此对象与指定对象是否相等</td></tr><tr><td>intValue()</td><td>int</td><td>以 int 型返回此 Integer 对象</td></tr><tr><td>shortValue()</td><td>short</td><td>以 short 型返回此 Integer 对象</td></tr><tr><td>longValue()</td><td>long</td><td>以 long 型返回此 Integer 对象</td></tr><tr><td>floatValue()</td><td>float</td><td>以 float 型返回此 Integer 对象</td></tr><tr><td>doubleValue()</td><td>double</td><td>以 double 型返回此 Integer 对象</td></tr><tr><td>toString()</td><td>String</td><td>返回一个表示该 Integer 值的 String 对象</td></tr><tr><td>valueOf(String str)</td><td>Integer</td><td>返回保存指定的 String 值的 Integer 对象</td></tr><tr><td>parseInt(String str)</td><td>int</td><td>将字符串参数作为有符号的十进制整数进行解析</td></tr><tr><td>parseInt(String str,int radix)</td><td>int</td><td>实现将字符串按照参数 radix 指定的进制转换为十进制</td></tr></tbody></table></figure><p>&nbsp;</p><h4><a name='header-n581' class='md-header-anchor '></a>2.Character 类</h4><p>Character 类型的对象包含类型为 char 的单个字段。</p><figure><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>isDigit(char ch)</td><td>boolean</td><td>确定字符是否为数字</td></tr><tr><td>isLetter(char ch)</td><td>boolean</td><td>确定字符是否为字母</td></tr><tr><td>isLowerCase(char ch)</td><td>boolean</td><td>确定字符是否为小写字母</td></tr><tr><td>isUpperCase(char ch)</td><td>boolean</td><td>确定字符是否为大写字母</td></tr><tr><td>isWhitespace(char ch)</td><td>boolean</td><td>确定字符是否为空白字符</td></tr><tr><td>isUnicodeIdentifierStart(char ch)</td><td>boolean</td><td>确定是否允许将指定字符作为 Unicode 标识符中的首字符</td></tr></tbody></table></figure><p>&nbsp;</p><h4><a name='header-n613' class='md-header-anchor '></a>3.Boolean 类</h4><p>一个 Boolean 类型的对象只包含一个类型为 boolean 的字段。</p><p>Boolean 类的构造方法也有两个：</p><ol start='' ><li>Boolean(boolean value)，创建一个表示 value 参数的 Boolean 对象，如<code>Boolean b = new Boolean(true)</code></li><li>Boolean(String s)，如果 String 参数不为 null 且在忽略大小写时等于 &quot;true&quot;,创建一个表示 true 值的 Boolean 对象，如<code>Boolean b = new Boolean(&quot;ok&quot;)</code>，为 false。</li></ol><figure><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>booleanValue()</td><td>boolean</td><td>将 Boolean 对象的值以对应的 boolean 值返回</td></tr><tr><td>equals(Object obj)</td><td>boolean</td><td>判断调用该方法的对象与 obj 是否相等。当且仅当参数不是 null，而且与调用该方法的对象一样都表示同一个 boolean 值的 Boolean 对象时，才返回 true</td></tr><tr><td>parseBoolean(String s)</td><td>boolean</td><td>将字符串参数解析为 boolean 值</td></tr><tr><td>toString()</td><td>String</td><td>返回表示该 boolean 值的 String 对象</td></tr><tr><td>valueOf(String s)</td><td>Boolean</td><td>返回一个用指定得字符串表示值的 boolean 值</td></tr></tbody></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n648' class='md-header-anchor '></a>三、Math</h3><figure><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>sin(double numvalue)</td><td>double</td><td>计算角 numvalue 的正弦值</td></tr><tr><td>cos(double numvalue)</td><td>double</td><td>计算角 numvalue 的余弦值</td></tr><tr><td>acos(double numvalue)</td><td>double</td><td>计算 numvalue 的反余弦</td></tr><tr><td>asin(double numvalue)</td><td>double</td><td>计算 numvalue 的反正弦</td></tr><tr><td>atan(double numvalue)</td><td>double</td><td>计算 numvalue 的反正切</td></tr><tr><td>pow(double a, double b)</td><td>double</td><td>计算 a 的 b 次方</td></tr><tr><td>sqrt(double numvalue)</td><td>double</td><td>计算给定值的正平方根</td></tr><tr><td>abs(int numvalue)</td><td>int</td><td>计算 int 类型值 numvalue 的绝对值，也接收 long、float 和 double 类型的参数</td></tr><tr><td>ceil(double numvalue)</td><td>double</td><td>返回大于等于 numvalue 的最小整数值</td></tr><tr><td>floor(double numvalue)</td><td>double</td><td>返回小于等于 numvalue 的最大整数值</td></tr><tr><td>max(int a, int b)</td><td>int</td><td>返回 int 型 a 和 b 中的较大值，也接收 long、float 和 double 类型的参数</td></tr><tr><td>min(int a, int b)</td><td>int</td><td>返回 a 和 b 中的较小值，也可接受 long、float 和 double 类型的参数</td></tr><tr><td>rint(double numvalue)</td><td>double</td><td>返回最接近 numvalue 的整数值</td></tr><tr><td>round(T arg)</td><td>arg 为 double 时返回 long，为 float 时返回 int</td><td>返回最接近 arg 的整数值</td></tr><tr><td>random()</td><td>double</td><td>返回带正号的 double 值，该值大于等于 0.0 且小于 1.0</td></tr></tbody></table></figure><p>&nbsp;</p><h3><a name='header-n715' class='md-header-anchor '></a>四、类 Class</h3><p>Class 类的实例表示正在运行的 Java 应用程序中的类或接口。在 Java 中，每个 Class 都有一个相应的 Class 对象，即每一个类，在生成的<code>.class</code>文件中，就会产生一个 Class 对象，用于表示这个类的类型信息。我们获取 Class 实例有三种方法：</p><ol start='' ><li>利用对象调用 <code>getClass()</code>方法获取该对象的 Class 实例</li><li>使用 Class 类的静态方法 <code>forName(String className)</code>，用类的名字获取一个 Class 实例</li><li>运用<code>.class</code>的方式来获取 Class 实例，对于基本数据类型的封装类，还可以采用<code>.TYPE</code>来获取相对应的基本数据类型的 Class 实例</li></ol><p><img src='https://doc.shiyanlou.com/document-uid79144labid1085timestamp1435763025133.png/wm' alt='Class 类对象访问' referrerPolicy='no-referrer' /></p><p><img src='https://doc.shiyanlou.com/document-uid79144labid1085timestamp1435763058113.png/wm' alt='Class 类对象访问结果' referrerPolicy='no-referrer' /></p><p>class 类没有共有的构造方法，它由 JVM 自动调用。</p><h3><a name='header-n727' class='md-header-anchor '></a>五、Object类</h3><figure><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>equals(Objectobj)</td><td>boolean</td><td>将当前对象实例与给定的对象进行比较，检查它们是否相等</td></tr><tr><td>finalize() throws Throwable</td><td>void</td><td>当垃圾回收器确定不存在对象的更多引用时，由对象的垃圾回收器调用此方法。通常被子类重写</td></tr><tr><td>getClass()</td><td>Class</td><td>返回当前对象的 Class 对象</td></tr><tr><td>toString()</td><td>String</td><td>返回此对象的字符串表示</td></tr><tr><td>wait() throws InterruptedException</td><td>void</td><td>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，使当前线程进入等待状态</td></tr></tbody></table></figure><h4><a name='header-n753' class='md-header-anchor '></a>toString()方法</h4><p>在Object类里面定义toString()方法的时候返回的对象在哈希code码(对象地址字符串)</p><p>可以通过重写toString()方法表示出对象的属性</p><h4><a name='header-n756' class='md-header-anchor '></a>equals和==的区别</h4><p>==是一个比较运算符，基本数据类型比较的是值，引用数据类型比较的是地址值。</p><p>equals()是一个方法，只能比较引用数据类型。重写前比较的是地址值，重写后比一般是比较对象的属性。</p><p><strong>除了String和封装器，equals()和“==”没什么区别</strong>
<strong>但String和封装器重写了equals()，所以在这里面，equals()指比较字符串或封装对象对应的原始值是否相等，&quot;==&quot;是比较两个对象是否为同一个对象</strong></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n763' class='md-header-anchor '></a>java日期和随机数</h2><p>学习 java.util 中的 Date 类、Calendar 类，Random 类以及 java.time 包中的 LocalTime 类。</p><h3><a name='header-n765' class='md-header-anchor '></a>一、java.util 和 java.time 包介绍</h3><p>java.util 包提供了一些实用的方法和数据结构。比如日期类 Date，日历类 Calendar 以及随机数类 Random，同时包里还提供了 collection 框架，像堆栈 Stack、向量 Vector、位集合 Bitset 以及哈希表 Hashtable 等表示数据结构的类。而 java.time 包是 java8 新提供的包，里面对时间和日期提供了新的 api，弥补了 java.util 包对日期和时间操作的不足。</p><p><img src='https://doc.shiyanlou.com/document-uid79144labid1089timestamp1435767072006.png/wm' alt='java.util层次' referrerPolicy='no-referrer' /></p><p>本次课程主要介绍 Date 类、Calendar 类、Random 类以及 LocalTime 类的相关知识，其他 collection 框架等方面的内容将在后面的课程进行介绍。</p><p>&nbsp;</p><h3><a name='header-n770' class='md-header-anchor '></a>二、Date 类和Calendar 类</h3><p>链接：<a href='https://www.shiyanlou.com/courses/109/labs/1119/document/#2.4%20java.time%20' target='_blank' class='url'>https://www.shiyanlou.com/courses/109/labs/1119/document/#2.4%20java.time%20</a>包</p><p>Date 类表示日期和时间，里面封装了操作日期和时间的方法。Date 类经常用来获取系统当前时间。</p><p>我们来看看类 Date 中定义的未过时的构造方法：</p><figure><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>Date()</td><td>构造一个 Date 对象并对其进行初始化以反映当前时间</td></tr><tr><td>Date(long date)</td><td>构造一个 Date 对象，并根据相对于 GMT 1970 年 1 月 1 日 00:00:00 的毫秒数对其进行初始化</td></tr></tbody></table></figure><p>### </p><p>在早期的 JDK 版本中，Date 类附有两大功能： 　　</p><ol start='' ><li>允许用年、月、日、时、分、秒来解释日期</li><li>允许对表示日期的字符串进行格式化和句法分析</li></ol><p>在 JDK1.1 中提供了类 Calendar 来完成第一种功能，类 DateFormat 来完成第二项功能。DateFormat 是 java.text 包中的一个类。与 Date 类有所不同的是，DateFormat 类可以接受用各种语言和不同习惯表示的日期字符串。</p><p>但是 Calendar 类是一个抽象类，它完成 Date 类与普通日期表示法之间的转换，而我们更多的是使用 Calendar 类的子类 GregorianCalendar 类。它实现了世界上普遍使用的公历系统。当然我们也可以继承 Calendar 类，然后自己定义实现日历方法。</p><p>&nbsp;</p><h3><a name='header-n794' class='md-header-anchor '></a>三、java.time 包</h3><p>因为 java8 之前的日期和时间 api 饱受诟病，比如线程安全问题，比如 Date 的月份是从 0 开始的！而 java.time 包中将月份封装成为了枚举类型。</p><p>首先了解一下 LocalTime 类，LocalTime 类是一个不可变类（也就是用 final 修饰的类），和 String 类一样，所以它是线程安全的。除了 LocalTime 还有 LocalDate（日期）、LocalDateTime（日期和时间）等，他们的使用方式都差不多。</p><p>初始化例子：LocalDateTime currentTime = LocalDateTime.now();</p><p><strong>Java8的DateTimeFormatter是线程安全的，而SimpleDateFormat并不是线程安全。</strong></p><p><strong>DateTimeFormatter可以用来格式化输出日期时间</strong></p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n802' class='md-header-anchor '></a>四、Random 类</h3><p>Java 实用工具类库中的类 java.util.Random 提供了产生各种类型随机数的方法。它可以产生 int、long、float、double 以及 Gaussian 等类型的随机数。这也是它与 java.lang.Math 中的方法 Random() 最大的不同之处，后者只产生 double 型的随机数。</p><figure><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>Random()</td><td>产生一个随机数需要基值，这里将系统时间作为 seed</td></tr><tr><td>Random(long seed)</td><td>使用单个 long 种子创建一个新的随机数生成器</td></tr></tbody></table></figure><p><strong>强调：种子数只是随机算法的起源数字，和生成的随机数字的区间无关。相同种子数的Random对象，相同次数生成的随机数字是完全相同的。</strong></p><p>普通方法原型：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//该方法是设定基值seed</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public synchronized void setSeed(long seed)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//该方法是产生一个整型随机数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public int nextInt()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//该方法是产生一个long型随机数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public long nextLong()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//该方法是产生一个Float型随机数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public float nextFloat()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//该方法是产生一个Double型随机数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public double nextDouble()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//该方法是产生一个double型的Gaussian随机数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public synchronized double nextGaussian()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">/*</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">synchronized  是 Java 语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">*/</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 572px;"></div><div class="CodeMirror-gutters" style="display: none; height: 572px;"></div></div></div></pre><p>例子：</p><p>1、生成[0,10]区间的整数</p><p>int n3 = r.nextInt(11);</p><p>相对于整数区间，[0,10]区间和[0,11)区间等价，所以即生成[0,11)区间的整数。</p><p>2、生成[-3,15)区间的整数</p><p>int n4 = r.nextInt(18) - 3;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n826' class='md-header-anchor '></a>Java 集合框架</h2><p>&nbsp;</p><p><img src='https://doc.shiyanlou.com/document-uid79144labid1102timestamp1435844913664.png/wm' alt='img' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h3><a name='header-n830' class='md-header-anchor '></a>一、Collection 接口</h3><p>它也是 List、Set 和 Queue 接口的父接口。Collection 接口中定义了可用于操作 List、Set 和 Queue 的方法——增删改查。</p><figure><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>add(E e)</td><td>boolean</td><td>向 collection 的尾部追加指定的元素（可选操作）</td></tr><tr><td>addAll(Collection&lt;? extend E&gt; c)</td><td>boolean</td><td>将指定 collection 中的所有元素都添加到此 collection 中（可选操作）</td></tr><tr><td>clear()</td><td>void</td><td>移除此 collection 中的所有元素（可选操作）</td></tr><tr><td>contains(Object o)</td><td>boolean</td><td>如果此 collection 包含指定的元素，则返回 true</td></tr><tr><td>containsAll(Collection&lt;?&gt; c)</td><td>boolean</td><td>如果此 collection 包含指定 collection 的所有元素，则返回 true</td></tr><tr><td>equals(Object o)</td><td>boolean</td><td>比较此 collection 与指定对象是否相等</td></tr><tr><td>hashCode()</td><td>int</td><td>返回此 collection 的哈希码值</td></tr><tr><td>isEmpty()</td><td>boolean</td><td>如果此 collection 不包含元素，则返回 true</td></tr><tr><td>iterator()</td><td>Iterator<E></td><td>返回在此 collection 的元素上进行迭代的迭代器</td></tr><tr><td>remove(Object o)</td><td>boolean</td><td>移除此 collection 中出现的首个指定元素(可选操作)</td></tr><tr><td>removeAll(Collection&lt;?&gt; c)</td><td>boolean</td><td>移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）</td></tr><tr><td>retainAll(Collection&lt;?&gt; c)</td><td>boolean</td><td>仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）</td></tr><tr><td>size()</td><td>int</td><td>返回此 collection 中的元素数</td></tr><tr><td>toArray()</td><td>Object[]</td><td>返回包含此 collection 中所有元素的数组</td></tr><tr><td>toArray(T[] a)</td><td><T> T[]</td><td>返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同</td></tr></tbody></table></figure><h3><a name='header-n897' class='md-header-anchor '></a>二、Map接口</h3><p>Map 接口也是一个非常重要的集合接口，用于存储键/值对。Map 中的元素都是成对出现的，键值对就像数组的索引与数组的内容的关系一样，将一个键映射到一个值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。我们可以通过键去找到相应的值。</p><p>value 可以存储任意类型的对象，我们可以根据 key 键快速查找 value。Map 中的键/值对以 Entry 类型的对象实例形式存在。</p><figure><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>clear()</td><td>void</td><td>从此映射中移除所用映射关系（可选操作）</td></tr><tr><td>containsKey(Object key)</td><td>boolean</td><td>如果此映射包含指定键的映射关系，则返回 true</td></tr><tr><td>containsValue(Object value)</td><td>boolean</td><td>如果此映射将一个或多个键映射到指定值，则返回 true</td></tr><tr><td>entrySet()</td><td>Set&lt;Map.Entry&lt;K,V&gt;&gt;</td><td>返回此映射中包含的映射关系的 Set 视图</td></tr><tr><td>equals(Object o)</td><td>boolean</td><td>比较指定的对象与此映射是否相等</td></tr><tr><td>get(Object key)</td><td>V</td><td>返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null</td></tr><tr><td>hashCode()</td><td>int</td><td>返回此映射的哈希码值</td></tr><tr><td>isEmpty()</td><td>boolean</td><td>如果此映射未包含键-值映射关系，则返回 true</td></tr><tr><td>keySet()</td><td>Set<K></td><td>返回此映射中包含的键的 Set 视图</td></tr><tr><td>put(K key, V value)</td><td>V</td><td>将指定的值与此映射中的指定键关联（可选操作）</td></tr><tr><td>putAll(Map&lt;? extends K, ? extends V&gt; m)</td><td>void</td><td>从指定映射中将所有映射关系复制到此映射中（可选操作）</td></tr><tr><td>remove(Object key)</td><td>V</td><td>如果存在一个键的映射关系，则将其从此映射中移除（可选操作）</td></tr><tr><td>size</td><td>int</td><td>返回此映射中的键-值映射关系数</td></tr><tr><td>values()</td><td>Collection<V></td><td>返回此映射中包含的值的 Collection 视图</td></tr></tbody></table></figure><p>&nbsp;</p><h3><a name='header-n962' class='md-header-anchor '></a>三、List 接口与 ArrayList 类</h3><p>List 是一个接口，不能实例化，需要一个具体类来实现实例化。List 集合中的对象按照一定的顺序排放，里面的内容可以重复。 List 接口实现的类有：ArrayList（实现动态数组），Vector（实现动态数组），LinkedList（实现链表），Stack（实现堆栈）。</p><p>List 在 Collection 基础上增加的方法：</p><figure><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>add(int index, E element)</td><td>void</td><td>在列表的指定位置插入指定元素（可选操作）</td></tr><tr><td>addAll(int index, Collection&lt;? extends E&gt; c)</td><td>boolean</td><td>将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作）</td></tr><tr><td>get(int index)</td><td>E</td><td>返回列表中指定位置的元素</td></tr><tr><td>indexOf(Object o)</td><td>int</td><td>返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1</td></tr><tr><td>lastIndexOf(Object o)</td><td>int</td><td>返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1</td></tr><tr><td>listIterator()</td><td>ListIterator<E></td><td>返回此列表元素的列表迭代器（按适当顺序）</td></tr><tr><td>listIterator(int index)</td><td>ListIterator<E></td><td>返回此列表元素的列表迭代器（按适当顺序），从列表的指定位置开始</td></tr><tr><td>remove(int index)</td><td>E</td><td>移除列表中指定位置的元素（可选操作）</td></tr><tr><td>set(int index, E element)</td><td>E</td><td>用指定元素替换列表中指定位置的元素（可选操作）</td></tr><tr><td>subList(int fromIndex, int toIndex)</td><td>List<E></td><td>返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图</td></tr></tbody></table></figure><p>定义时可以通过List<T>来规定集合元素的类型</p><p>ArrayList　类实现一个<strong>可增长的动态数组</strong>，它<strong>可以存储不同类型的对象，而数组则只能存放特定数据类型的值。</strong></p><p>Arrays 类， Arrays 包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表。</p><p>List 有两种基本的类型，除了 ArrayList 外，还有 LinkedList，LinkedList 类用于创建链表数据结构，两者的对比如下：</p><ul><li><strong>ArrayList：它擅长于随机访问元素，但是插入和移除元素时较慢。</strong></li><li><strong>LinkedList（链表）：它通过代价较低的在 List 中进行插入和删除操作，提供了优化的顺序访问，它在随机访问方面相对较慢，但是它的特性集较 ArrayList 更大。</strong></li></ul><p>&nbsp;</p><h3><a name='header-n1020' class='md-header-anchor '></a>四、Set 接口和 HashSet 类</h3><p>Set 接口也是 Collection 接口的子接口，它有一个很重要也是很常用的实现类——HashSet，Set 是元素无序并且不包含重复元素的 collection（List 可以重复），被称为集。</p><p>HashSet 由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是<strong>它不保证该顺序恒久不变</strong>。</p><p><strong>Set与List的不同，由于无序，所以不提供set()方法get()方法等</strong></p><p><strong>Set里遍历元素只能用foreach 和 iterator</strong> </p><p>&nbsp;</p><h3><a name='header-n1026' class='md-header-anchor '></a>五、HashSet和HashMap的区别</h3><figure><table><thead><tr><th><em>HashMap</em></th><th><em>HashSet</em></th></tr></thead><tbody><tr><td>HashMap实现了Map接口</td><td>HashSet实现了Set接口</td></tr><tr><td>HashMap储存键值对</td><td>HashSet仅仅存储对象</td></tr><tr><td>使用<strong>put()</strong>方法将元素放入map中</td><td>使用<strong>add()</strong>方法将元素放入set中</td></tr><tr><td>HashMap中使用键对象来计算hashcode值</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td></tr><tr><td>HashMap比较快，因为是使用唯一的键来获取对象</td><td>HashSet较HashMap来说比较慢</td></tr></tbody></table></figure><p>HashSet底层通过包装HashMap来实现<strong>（适配器模式）</strong>，HashSet在添加一个值的时候，实际上是将此值作为HashMap中的key来进行保存。</p><h3><a name='header-n1047' class='md-header-anchor '></a>六、HashMap 类</h3><p>HashMap 是基于哈希表的 Map 接口的一个重要实现类。HashMap 中的 Entry （键值对）对象是无序排列的，Key 值和 value 值都可以为 null，但是一个 HashMap 只能有一个 key 值为 null 的映射。</p><p><strong>1、key 值不可重复，value可以
2、每个键最多只能映射到一个值</strong>
<strong>3、支持泛型，如Map&lt;K,V&gt;</strong>
<strong>4、提供了返回key集合【keySet()】，value集合【values()】以及Entry(键值对)【entrySet()】集合的方法</strong></p><p>HashMap：基于哈希表实现。使用HashMap要求添加的键类明确定义了hashCode()和equals()[可以重写hashCode()和equals()]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子。</p><p>TreeMap：基于红黑树实现。所有的元素都保持着某种固定的顺序。TreeMap没有调优选项，因为该树总处于平衡状态。</p><h3><a name='header-n1052' class='md-header-anchor '></a>七、结合Util工具包</h3><p>数组操控工具：<strong>Arrays工具累，Collections工具类</strong></p><p>Collections工具类比较的内容必须继承Comparable接口</p><p>Comparable接口-可比较的:默认比较规则
实现该接口表示：这个类的实例可以比较大小，可以进行自然排序
定义了默认的比较规则
Comparable接口的实现类必须实现compateTo()方法
compareTo()方法返回正数表示大，负数表示小，0表示相等</p><p>Comparator接口-比较工具接口：<strong>临时</strong>比较规则
用于定义临时比较规则，而不是默认比较规则。
Comparator的实现类必须实现compare()方法
Comparable和Comparator都是java集合框架的成员</p><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n1059' class='md-header-anchor '></a>Java io</h2><p><a href='https://www.shiyanlou.com/courses/109/labs/1121/document/' target='_blank' class='url'>https://www.shiyanlou.com/courses/109/labs/1121/document/</a></p><p>大部分程序都需要进行输入/输出处理，比如从键盘读取数据、从屏幕中输出数据、从文件中写数据等等。在 Java 中，把这些不同类型的输入、输出源抽象为流（Stream），而其中输入或输出的数据则称为数据流（Data Stream），用统一的接口表示，从而使程序设计简单明了。</p><p><img src='https://doc.shiyanlou.com/document-uid79144labid1113timestamp1436110914669.png/wm' alt='流' referrerPolicy='no-referrer' /></p><p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p><p>流一般分为输入流（Input Stream）和输出流（Output Stream）两类，但这种划分并不是绝对的。比如一个文件，当向其中写数据时，它就是一个输出流；当从其中读取数据时，它就是一个输入流。当然，键盘只是一个输入流，而屏幕则只是一个输出流。（其实我们可以通过一个非常简单的方法来判断，只要是<strong>向内存中写入就是输入流，从内存中写出就是输出流</strong>）</p><p><img src='https://doc.shiyanlou.com/document-uid79144labid1113timestamp1436110985475.png/wm' alt='I/O 概述' referrerPolicy='no-referrer' /></p><h3><a name='header-n1066' class='md-header-anchor '></a>一、字节流</h3><h4><a name='header-n1067' class='md-header-anchor '></a>1、基类：InputStream 和 OutputStream</h4><p>字节流主要操作 byte 类型数据，以 byte 数组为准，java 中每一种字节流的基本功能依赖于基本类 InputStream 和 Outputstream，<strong>他们是抽象类，不能直接使用。<code>字节流能处理所有类型的数据（如图片、avi等）</code>。</strong></p><p>&nbsp;</p><p>InputStream 是所有表示字节输入流类的基类，继承它的子类要重新定义其中所定义的抽象方法。InputStream 是从装置来源地读取数据的抽象表示，例如 System 中的标准输入流 in 对象就是一个 InputStream 类型的实例。</p><p>InputStream 类中，方法 read() 提供了三种从流中读数据的方法：</p><ol start='' ><li>int read()：从输入流中读一个字节，形成一个 0~255 之间的整数返回（是一个抽象方法）</li><li>int read(byte b[])：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</li><li>int read(byte b[],int off,int len)：从输入流中读取长度为 len 的数据，写入数组 b 中从索引 off 开始的位置，并返回读取得字节数。</li></ol><p>对于这三个方法，<strong>若返回-1，表明流结束，否则，返回实际读取的字符数。</strong></p><p>&nbsp;</p><p>OutputStream 是所有表示字节输出流类的基类。子类要重新定义其中所定义的抽象方法，OutputStream 是用于将数据写入目的地的抽象表示。例如 System 中的标准输出流对象 out 其类型是 java.io.PrintStream，这个类是 OutputStream 的子类。</p><figure><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>write(int b)throws IOException</td><td>将指定的字节写入此输出流（抽象方法），<strong>只写出一个byte到流，写的是b的低八位</strong></td></tr><tr><td>write(byte b[])throws IOException</td><td>将字节数组中的数据输出到流中</td></tr><tr><td>write(byte b[], int off, int len)throws IOException</td><td>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流</td></tr><tr><td>flush()throws IOException</td><td>刷新此输出流并强制写出所有缓冲的输出字节</td></tr><tr><td>close()throws IOException</td><td>关闭流</td></tr></tbody></table></figure><p>例子：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">import java.io.IOException;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">import java.io.InputStream;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">import java.io.OutputStream;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class test {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">/**</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> * 把输入流中的所有内容赋值到输出流中</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> * @param in</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> * @param out</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> * @throws IOException</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> */</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public void copy(InputStream in, OutputStream out) throws IOException {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  byte[] buf = new  byte[4096];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int len = in.read(buf);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  //read 是一个字节一个字节地读，字节流的结尾标志是-1</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  while (len != -1){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  out.write(buf, 0, len);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  len = in.read(buf);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public static void main(String[] args) throws IOException {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // TODO Auto-generated method stub</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  test t = new test();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println("输入字符：");</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  t.copy(System.in, System.out);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">用例：</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">输入字符：ABC</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">输出：ABC</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 780px;"></div><div class="CodeMirror-gutters" style="display: none; height: 780px;"></div></div></div></pre><h4><a name='header-n1103' class='md-header-anchor '></a>2、文件流</h4><p>在 I/O 处理中，最常见的就是对文件的操作。java.io 包中所提供的文件操作类包括：</p><ol start='' ><li>用于读写本地文件系统中的文件：FileInputStream 和 FileOutputStream</li><li>描述本地文件系统中的文件或目录：File、FileDescriptor 和 FilenameFilter</li><li>提供对本地文件系统中文件的随机访问支持：RandomAccessFile</li></ol><p>今天我们来学习文件流的 FileInputStream 和 FileOutputStream 。</p><p>FileInputStream 类用于打开一个输入文件，若要打开的文件不存在，则会产生异常 FileNotFoundException，这是一个非运行时异常，必须捕获或声明抛弃；</p><p>FileOutputStream 类用来打开一个输出文件，若要打开的文件不存在，则会创建一个新的文件，否则原文件的内容会被新写入的内容所覆盖；</p><p><strong>在进行文件的读/写操作时，会产生非运行时异常 IOException，必须捕获或声明抛弃（</strong>其他的输入/输出流处理时也同样需要进行输入/输出异常处理）。</p><p>文件流的构造方法：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//打开一个以 f 描述的文件作为输入</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">FileInputStream(File f)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//打开一个文件路径名为 name 的文件作为输入</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">FileInputStream(String name)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//创建一个以 f 描述的文件作为输出</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//如果文件存在，则其内容被清空</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">FileOutputStream(File f)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//创建一个文件路径名为 name 的文件作为输出</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//文件如果已经存在，则其内容被清空</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">FileOutputStream(String name)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//创建一个文件路径名为 name 的文件作为输出</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//文件如果已经存在，则在该输出上输出的内容被接到原有内容之后</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">FileOutputStream(String name, boolean append)</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 442px;"></div><div class="CodeMirror-gutters" style="display: none; height: 442px;"></div></div></div></pre><h4><a name='header-n1118' class='md-header-anchor '></a>3、缓冲流（速度快）</h4><p>类 BufferedInputStream 和 BufferedOutputStream 实现了带缓冲的过滤流，它提供了缓冲机制，把任意的 I/O 流“捆绑”到缓冲流上，可以提高 I/O 流的读取效率。</p><p>在初始化时，除了要指定所连接的 I/O 流之外，还可以指定缓冲区的大小。缺省时是用 32 字节大小的缓冲区；最优的缓冲区大小常依赖于主机操作系统、可使用的内存空间以及机器的配置等；一般缓冲区的大小为内存页或磁盘块等的整数倍。</p><p>BufferedInputStream 的数据成员 buf 是一个位数组，默认为 2048 字节。当读取数据来源时例如文件，BufferedInputStream 会尽量将 buf 填满。当使用 read ()方法时，实际上是先读取 buf 中的数据，而不是直接对数据来源作读取。当 buf 中的数据不足时，BufferedInputStream 才会再实现给定的 InputStream 对象的 read() 方法，从指定的装置中提取数据。</p><p>BufferedOutputStream 的数据成员 buf 是一个位数组，默认为 512 字节。当使用 write() 方法写入数据时，实际上会先将数据写至 buf 中，当 buf 已满时才会实现给定的 OutputStream 对象的 write() 方法，将 buf 数据写至目的地，而不是每次都对目的地作写入的动作。 </p><p>构造方法：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//[ ]里的内容代表选填</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">BufferedInputStream(InputStream in [, int size])</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">BufferedOutputStream(OutputStream out [, int size])</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 78px;"></div><div class="CodeMirror-gutters" style="display: none; height: 78px;"></div></div></div></pre><p><strong>一般可以与其他字节流结合起来使用</strong>，例如：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">FileInputStream in = new FileInputStream("file.txt");</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">FileOutputStream out = new FileOutputStream("file2.txt");</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//设置输入缓冲区大小为256字节</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">BufferedInputStream bin = new BufferedInputStream(in,256)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">BufferedOutputStream bout = new BufferedOutputStream(out,256)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">int len;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">byte bArray[] = new byte[256];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">len = bin.read(bArray); //len 中得到的是实际读取的长度，bArray 中得到的是数据</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 234px;"></div><div class="CodeMirror-gutters" style="display: none; height: 234px;"></div></div></div></pre><p><strong>对于 BufferedOutputStream，只有缓冲区满时，才会将数据真正送到输出流，但可以使用 flush() 方法人为地将尚未填满的缓冲区中的数据送出。</strong></p><h4><a name='header-n1128' class='md-header-anchor '></a>4、 数据流</h4><p>接口 DataInput 和 DataOutput，设计了一种较为高级的数据输入输出方式：除了可处理字节和字节数组外，还可以处理 int、float、boolean 等基本数据类型，这些数据在文件中的表示方式和它们在内存中的一样，无须转换，如 read(), readInt(), readByte()...; write(), writeChar(), writeBoolean()...此外，还可以用 readLine()方法读取一行信息。</p><ol start='' ><li><strong>分别实现了 DataInput 和 DataOutput 接口</strong></li><li>在提供字节流的读写手段同时，以统一的形式向输入流中写入 boolean，int，long，double 等基本数据类型，并可以再次把基本数据类型的值读取回来。</li><li>提供了字符串读写的手段</li></ol><p>数据流可以连接一个已经建立好的数据对象，例如网络连接、文件等。数据流可以通过如下方式建立：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">FileInputStream fis = new FileInputStream("file1.txt");</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">FileOutputStream fos = new FileOutputStream("file2.txt");</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">DataInputStream dis = new DataInputStream(fis);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">DataOutputStream dos = new DataOutputStream(fos);</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 104px;"></div><div class="CodeMirror-gutters" style="display: none; height: 104px;"></div></div></div></pre><h4><a name='header-n1139' class='md-header-anchor '></a>5、标准流、内存读写流、顺序输入流</h4><p><strong>标准流：</strong></p><p>语言包 java.lang 中的 System 类管理标准输入/输出流和错误流。
System.in<code>从 InputStream 中继承而来，用于从标准输入设备中获取输入数据（通常是键盘）</code>System.out<code>从 PrintStream 中继承而来，把输入送到缺省的显示设备（通常是显示器）</code>System.err`也是从 PrintStream 中继承而来，把错误信息送到缺省的显示设备（通常是显示器）
每当 main 方法被执行时，就会自动生产上述三个对象。</p><p><strong>内存读写流：</strong></p><p>为了支持在内存上的 I/O，java.io 中提供了类：ByteArrayInputStream、ByteArrayOutputStream 和 StringBufferInputStream</p><ol start='' ><li>ByteArrayInputStream 可以从指定的字节数组中读取数据</li><li>ByteArrayOutputStream 中提供了缓冲区可以存放数据（缓冲区大小可以在构造方法中设定，缺省为 32），可以用 write() 方法向其中写入数据，然后用 toByteArray() 方法将缓冲区中的有效字节写到字节数组中去。size() 方法可以知道写入的字节数；reset() 可以丢弃所有内容。</li><li>StringBufferInputStream 与 ByteArrayInputStream 相类似，不同点在于它是从字符缓冲区 StringBuffer 中读取 16 位的 Unicode 数据，而不是 8 位的字节数据（已被 StringReader 取代）</li></ol><p><strong>顺序输入流</strong></p><p>java.io 中提供了类 SequenceInputStream，使应用程序可以将几个输入流顺序连接起来。顺序输入流提供了将多个不同的输入流统一为一个输入流的功能，这使得程序可能变得更加简洁。</p><p>例如：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">FileInputStream f1,f2;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">String s;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">f1 = new FileInputStream("file1.txt");</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">f2 = new FileInputStream("file2.txt");</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">SequenceInputStream fs = new SequenceInputStream(f1,f2);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">DataInputeStream ds = new DataInputStream(fs);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">while((s = ds.readLine()) != null) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println(s);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 234px;"></div><div class="CodeMirror-gutters" style="display: none; height: 234px;"></div></div></div></pre><h3><a name='header-n1155' class='md-header-anchor '></a>二、字符流</h3><h4><a name='header-n1156' class='md-header-anchor '></a>1、基类：Reader 和 Writer</h4><p><strong>字符流以字符为单位，根据码表映射字符，一次可能读多个字节，只能处理字符类型的数据。</strong></p><p>同类 InputStream 和 OutputStream 一样，Reader 和 Writer 也是抽象类，只提供了一系列用于字符流处理的接口。它们的方法与类 InputStream 和 OutputStream 类似，只不过其中的参数换成字符或字符数组。</p><p>Reader 是所有的输入字符流的父类，它是一个抽象类：</p><figure><table><thead><tr><th>方法</th><th>返回值</th></tr></thead><tbody><tr><td>close()</td><td>void</td></tr><tr><td>mark (int readAheadLimit)</td><td>void</td></tr><tr><td>markSupported()</td><td>boolean</td></tr><tr><td>read()</td><td>int</td></tr><tr><td>read(char[] cbuf, int off,int len)</td><td>int</td></tr><tr><td>ready()</td><td>boolean</td></tr><tr><td>reset()</td><td>void</td></tr><tr><td>skip(long n)</td><td>long</td></tr></tbody></table></figure><p>Writer 是所有的输出字符流的父类，它是一个抽象类。 Writer 的方法：</p><figure><table><thead><tr><th>方法</th><th>返回值</th></tr></thead><tbody><tr><td>close()</td><td>void</td></tr><tr><td>flush()</td><td>void</td></tr><tr><td>write(char[] cbuf)</td><td>void</td></tr><tr><td>write(char[] cbuf, int off,int len)</td><td>void</td></tr><tr><td>write(int c)</td><td>void</td></tr><tr><td>write(String str)</td><td>void</td></tr><tr><td>write(String str, int off, int len)</td><td>void</td></tr></tbody></table></figure><p>&nbsp;</p><h4><a name='header-n1215' class='md-header-anchor '></a>2、InputStreamReader 和 OutputStreamWriter</h4><p>InputStreamReader 和 OutputStreamWriter 是 java.io 包中用于处理字符流的最基本的类，用来在字节流和字符流之间作为中介：从字节输入流读入字节，并按编码规范转换为字符；往字节输出流写字符时先将字符按编码规范转换为字节。使用这两者进行字符处理时，在构造方法中应指定一定的平台规范，以便把以字节方式表示的流转换为特定平台上的字符表示。</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">InputStreamReader(InputStream in); //缺省规范说明</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//指定规范 enc</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">InputStreamReader(InputStream in, String enc);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">OutputStreamWriter(OutputStream out); //缺省规范说明</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//指定规范 enc</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">OutputStreamWriter(OutputStream out, String enc);</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 234px;"></div><div class="CodeMirror-gutters" style="display: none; height: 234px;"></div></div></div></pre><p>如果读取的字符流不是来自本地时（比如网上某处与本地编码方式不同的机器），那么在构造字符输入流时就不能简单地使用缺省编码规范，而应该指定一种统一的编码规范“ISO 8859_1”，这是一种映射到 ASCCII 码的编码方式，能够在不同平台之间正确转换字符。</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">InputStreamReader ir = new InputStreamReader(is,"8859_1");</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 26px;"></div><div class="CodeMirror-gutters" style="display: none; height: 26px;"></div></div></div></pre><p>&nbsp;</p><h4><a name='header-n1221' class='md-header-anchor '></a>3、缓存流</h4><p>除了 read() 和 write() 方法外，它还提供了整行字符处理方法：</p><ol start='' ><li>public String readLine()：BufferedReader 的方法，从输入流中读取一行字符，行结束标志<code>\n</code>、<code>\r</code>或者两者一起（这是根据系统而定的）</li><li>public void newLine()：BufferedWriter 的方法，向输出流中写入一个行结束标志，它不是简单地换行符<code>\n</code>或<code>\r</code>，而是系统定义的行隔离标志（line separator）。</li></ol><p>例子：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">import java.io.BufferedReader;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">import java.io.FileInputStream;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">import java.io.IOException;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">import java.io.InputStreamReader;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class FileToUnicode {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  public static void main(String args[]) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  try {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  FileInputStream fis = new FileInputStream("file1.txt");</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  InputStreamReader dis = new InputStreamReader(fis);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  BufferedReader reader = new BufferedReader(dis);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  String s;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  //每次读取一行，当改行为空时结束</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  while((s = reader.readLine()) != null){</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println("read:" + s);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  dis.close();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  catch(IOException e) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  System.out.println(e);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 598px;"></div><div class="CodeMirror-gutters" style="display: none; height: 598px;"></div></div></div></pre><h4><a name='header-n1230' class='md-header-anchor '></a>4、其它字符流类</h4><p>这里我们就列举一下有哪些类，具体的就不再讲解了。</p><ol start='' ><li><p>对字符数组进行处理： CharArrayReader、CharArrayWrite</p></li><li><p>对文本文件进行处理：FileReader、FileWriter</p></li><li><p>对字符串进行处理：StringReader、StringWriter</p></li><li><p>过滤字符流：FilterReader、FileterWriter</p></li><li><p>管道字符流：PipedReader、PipedWriter</p></li><li><p>行处理字符流：LineNumberReader</p></li><li><p>打印字符流：PrintWriter</p><p>&nbsp;</p><p>&nbsp;</p></li></ol><h3><a name='header-n1249' class='md-header-anchor '></a>三、File文件操作</h3><p><a href='https://www.shiyanlou.com/courses/109/labs/1123/document/' target='_blank' class='url'>https://www.shiyanlou.com/courses/109/labs/1123/document/</a></p><p>java.io 定义的大多数类都是流式操作，但 File 类不是。它直接处理文件和文件系统。File 类没有指定信息怎样从文件读取或向文件存储；它<strong>描述了文件本身的属性</strong>。File 对象用来获取或处理与磁盘文件相关的信息，例如权限，时间，日期和目录路径。此外，File 还浏览子目录层次结构。Java 中的目录当成 File 对待，它具有附加的属性——一个可以被 list( )方法检测的文件名列表。</p><p>File 的构造方法：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。 </span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">File(File parent, String child) </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例 &nbsp; &nbsp; &nbsp; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">File(String pathname) </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">// 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">File(String parent, String child) </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//通过将给定的 file: URI 转换为一个抽象路径名来创建一个新的 File 实例</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">File(URI uri) </span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 286px;"></div><div class="CodeMirror-gutters" style="display: none; height: 286px;"></div></div></div></pre><p>例如:</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//一个目录路径参数</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">File f1 = new File("/Users/mumutongxue/");</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//对象有两个参数——路径和文件名</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">File f2 = new File("/Users/mumutongxue/","a.bat");</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//指向f1文件的路径及文件名</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">File f3 = new File(f1,"a.bat");</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 208px;"></div><div class="CodeMirror-gutters" style="display: none; height: 208px;"></div></div></div></pre><p>&nbsp;</p><h3><a name='header-n1257' class='md-header-anchor '></a>四、RandomAccessFile类</h3><ol start='' ><li>该对象只能操作文件，所以构造函数接收两种类型的参数：a.字符串文件路径；b.File对象。</li><li><strong>该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw)，支持随机访问文件，可以访问文件的任意位置；打开文件时文件指针在开头pointer=0；</strong></li><li><strong>写方法 raf.write(int) ---&gt; 只写一个字节（后八位），同时指针指向下一个位置，或者也可以直接写入一个字节数组byte[]，或者直接调用writeInt(i)</strong></li><li>读方法int b=raf.read() ---&gt;读一个字节</li></ol><p>&nbsp;</p><p>RandomAccessFile 提供了支持随机文件操作的方法：</p><ol start='' ><li>readXXX()或者 writeXXX():如 ReadInt(),ReadLine(),WriteChar(),WriteDouble()等</li><li>int skipBytes(int n):将指针向下移动若干字节</li><li>length():返回文件长度</li><li>long getFilePointer():返回指针当前位置</li><li><strong>void seek(long pos):将指针调用所需位置</strong></li></ol><p>在生成一个随机文件对象时，除了要指明文件对象和文件名之外，还需要指明访问文件的模式。</p><p>我们来看看 RandomAccessFile 的构造方法：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1282" mdtype="fences">RandomAccessFile(File file,String mode)
RandomAccessFile(String name,String mode)
</pre><p>mode 的取值：</p><ul><li><code>r</code>:只读，任何写操作都讲抛出 IOException</li><li><code>rw</code>:读写，文件不存在时会创建该文件，文件存在是，原文件内容不变，通过写操作改变文件内容。</li><li><code>rws</code>:打开以便读取和写入，对于 &quot;rw&quot;，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。</li><li><code>rwd</code>:打开以便读取和写入，对于 &quot;rw&quot;，还要求对文件内容的每个更新都同步写入到底层存储设备。</li></ul><p>例子：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1294" mdtype="fences" style="break-inside: unset;">import java.io.IOException;
import java.io.RandomAccessFile;

public class  FileDemo {
    public static void main(String[] args){

            int data_arr[] = {12, 32, 43, 45, 1, 5};
            try {
                RandomAccessFile randf=new RandomAccessFile("temp.dat","rw");
                for(int i = 0; i &lt; data_arr.length; i++){
                    randf.writeInt(data_arr[i]);
                }
                for(int i = data_arr.length-1 ; i &gt;= 0; i--){
                    //int 数据占4个字节
                    randf.seek(i * 4L);
                    System.out.println(randf.readInt());
                }
                randf.close();
            }catch(IOException e){
                System.out.println("File access error" + e);
            }
    }
}

输出结果：
5  1  45  43  32  12
</pre></div>
</body>
</html>