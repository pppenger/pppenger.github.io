<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>javabasic</title><link href='night/mermaid.dark.css' rel='stylesheet' type='text/css' />
<link href='night/codeblock.dark.css' rel='stylesheet' type='text/css' />
<link href='night/sourcemode.dark.css' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:first-child { margin-top: -20px; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


.cm-s-inner .cm-variable, .cm-s-inner .cm-operator, .cm-s-inner .cm-property { color: rgb(184, 191, 198); }
.cm-s-inner .cm-keyword { color: rgb(200, 143, 208); }
.cm-s-inner .cm-tag { color: rgb(125, 244, 106); }
.cm-s-inner .cm-attribute { color: rgb(117, 117, 228); }
.CodeMirror div.CodeMirror-cursor { border-left: 1px solid rgb(184, 191, 198); z-index: 3; }
.cm-s-inner .cm-string { color: rgb(210, 107, 107); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(218, 146, 74); }
.cm-s-inner .cm-header, .cm-s-inner .cm-def, .cm-s-inner.cm-header, .cm-s-inner.cm-def { color: rgb(141, 141, 240); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(87, 172, 87); }
.cm-s-inner .cm-hr { color: rgb(216, 213, 213); }
.cm-s-inner .cm-link { color: rgb(211, 211, 239); }
.cm-s-inner .cm-negative { color: rgb(217, 80, 80); }
.cm-s-inner .cm-positive { color: rgb(80, 230, 80); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta, .cm-s-inner .cm-qualifier { color: rgb(183, 179, 179); }
.cm-s-inner .cm-builtin { color: rgb(243, 179, 248); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(132, 182, 203); }
.cm-s-inner .cm-number { color: rgb(100, 171, 143); }
.cm-s-inner .cm-variable { color: rgb(184, 191, 198); }
.cm-s-inner .cm-variable-2 { color: rgb(159, 186, 213); }
.cm-s-inner .cm-variable-3 { color: rgb(28, 198, 133); }
.CodeMirror-selectedtext, .CodeMirror-selected { background: rgb(74, 137, 220); text-shadow: none; color: rgb(255, 255, 255) !important; }
.CodeMirror-gutters { border-right: none; }


:root { --bg-color: #363B40; --side-bar-bg-color: #2E3033; --text-color: #b8bfc6; --select-text-bg-color:#4a89dc; --control-text-color: #b7b7b7; --control-text-hover-color: #eee; --window-border: 1px solid #555; --active-file-bg-color: rgb(34, 34, 34); --active-file-border-color: #8d8df0; --active-file-text-color: white; --item-hover-bg-color: #70717d; --item-hover-text-color: white; --primary-color: #6dc1e7; --rawblock-edit-panel-bd: #4B535A; }
html { font-size: 16px; }
html, body { text-size-adjust: 100%; background: var(--bg-color); fill: currentcolor; }
#write { max-width: 914px; }
html, body, button, input, select, textarea, div.code-tooltip-content { color: rgb(184, 191, 198); border-color: transparent; }
div.code-tooltip, .md-hover-tip .md-arrow::after { background: rgb(75, 83, 90); }
.popover.bottom > .arrow::after { border-bottom-color: rgb(75, 83, 90); }
html, body, button, input, select, textarea { font-style: normal; line-height: 1.625rem; font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; }
hr { height: 2px; border: 0px; margin: 24px 0px !important; }
h1, h2, h3, h4, h5, h6 { font-family: "Lucida Grande", Corbel, sans-serif; font-weight: normal; clear: both; word-wrap: break-word; margin: 0px; padding: 0px; color: rgb(222, 222, 222); }
h1 { font-size: 2.5rem; line-height: 2.75rem; margin-bottom: 1.5rem; letter-spacing: -1.5px; }
h2 { font-size: 1.63rem; line-height: 1.875rem; margin-bottom: 1.5rem; letter-spacing: -1px; font-weight: bold; }
h3 { font-size: 1.17rem; line-height: 1.5rem; margin-bottom: 1.5rem; letter-spacing: -1px; font-weight: bold; }
h4 { font-size: 1.12rem; line-height: 1.375rem; margin-bottom: 1.5rem; color: white; }
h5 { font-size: 0.97rem; line-height: 1.25rem; margin-bottom: 1.5rem; font-weight: bold; }
h6 { font-size: 0.93rem; line-height: 1rem; margin-bottom: 0.75rem; color: white; }
@media (min-width: 980px) {
  h3.md-focus::before, h4.md-focus::before, h5.md-focus::before, h6.md-focus::before { color: rgb(221, 221, 221); border: 1px solid rgb(221, 221, 221); border-radius: 3px; position: absolute; left: -1.64286rem; top: 0.357143rem; float: left; font-size: 9px; padding-left: 2px; padding-right: 2px; vertical-align: bottom; font-weight: normal; line-height: normal; }
  h3.md-focus::before { content: "h3"; }
  h4.md-focus::before { content: "h4"; }
  h5.md-focus::before { content: "h5"; top: 0px; }
  h6.md-focus::before { content: "h6"; top: 0px; }
}
a { text-decoration: none; outline: 0px; }
a:hover { outline: 0px; }
a:focus { outline: dotted thin; }
sup.md-footnote { background-color: rgb(85, 85, 85); color: rgb(221, 221, 221); }
p { word-wrap: break-word; }
p, ul, dd, ol, hr, address, pre, table, iframe, .wp-caption, .wp-audio-shortcode, .wp-video-shortcode { margin-top: 0px; margin-bottom: 1.5rem; }
li > blockquote { margin-bottom: 0px; }
audio:not([controls]) { display: none; }
[hidden] { display: none; }
.in-text-selection, ::selection { background: rgb(74, 137, 220); color: rgb(255, 255, 255); text-shadow: none; }
ul, ol { padding: 0px 0px 0px 1.875rem; }
ul { list-style: square; }
ol { list-style: decimal; }
ul ul, ol ol, ul ol, ol ul { margin: 0px; }
b, th, dt, strong { font-weight: bold; }
i, em, dfn, cite { font-style: italic; }
blockquote { margin: 35px 0px 1.875rem 1.875rem; border-left: 2px solid rgb(71, 77, 84); padding-left: 30px; }
pre, code, kbd, tt, var { background: rgba(0, 0, 0, 0.05); font-size: 0.875rem; font-family: Monaco, Consolas, "Andale Mono", "DejaVu Sans Mono", monospace; }
kbd { padding: 2px 4px; font-size: 90%; color: rgb(255, 255, 255); background-color: rgb(51, 51, 51); border-radius: 3px; box-shadow: rgba(0, 0, 0, 0.25) 0px -1px 0px inset; }
pre.md-fences { padding: 10px 30px; margin-bottom: 20px; border: 1px solid; }
.md-fences .code-tooltip { bottom: -3.2em; }
.enable-diagrams pre.md-fences[lang="sequence"] .code-tooltip, .enable-diagrams pre.md-fences[lang="flow"] .code-tooltip, .enable-diagrams pre.md-fences[lang="mermaid"] .code-tooltip { bottom: -2.2em; right: 4px; }
code, kbd, tt, var { padding: 2px 5px; }
table { max-width: 100%; width: 100%; border-collapse: collapse; border-spacing: 0px; }
th, td { padding: 5px 10px; vertical-align: top; }
a { transition: all 0.2s ease-in-out; }
hr { background: rgb(71, 77, 84); }
h1 { margin-top: 2em; }
a { color: rgb(224, 224, 224); text-decoration: underline; }
a:hover { color: rgb(255, 255, 255); }
.md-inline-math script { color: rgb(129, 177, 219); }
b, th, dt, strong { color: rgb(222, 222, 222); }
mark { background: rgb(211, 212, 14); }
blockquote { color: rgb(157, 162, 166); }
table a { color: rgb(222, 222, 222); }
th, td { border: 1px solid rgb(71, 77, 84); }
.task-list { padding-left: 0px; }
.md-task-list-item { padding-left: 1.25rem; }
.md-task-list-item > input { top: auto; }
.md-task-list-item > input::before { content: ""; display: inline-block; width: 0.875rem; height: 0.875rem; vertical-align: middle; text-align: center; border: 1px solid rgb(184, 191, 198); background-color: rgb(54, 59, 64); margin-top: -0.4rem; }
.md-task-list-item > input:checked::before, .md-task-list-item > input[checked]::before { content: "√"; font-size: 0.625rem; line-height: 0.625rem; color: rgb(222, 222, 222); }
.CodeMirror-gutters { background: var(--bg-color); border-right: 1px solid transparent; }
.auto-suggest-container { border: 0px; background-color: rgb(82, 92, 101); }
#typora-quick-open { background-color: rgb(82, 92, 101); }
#typora-quick-open input { background-color: rgb(82, 92, 101); border-width: 0px 0px 1px; border-top-style: initial; border-right-style: initial; border-left-style: initial; border-top-color: initial; border-right-color: initial; border-left-color: initial; border-image: initial; border-bottom-style: solid; border-bottom-color: grey; }
.typora-quick-open-item { background-color: inherit; color: inherit; }
.typora-quick-open-item.active, .typora-quick-open-item:hover { background-color: rgb(77, 139, 219); color: white; }
.typora-quick-open-item:hover { background-color: rgba(77, 139, 219, 0.8); }
.typora-search-spinner > div { background-color: rgb(255, 255, 255); }
#write pre.md-meta-block { border-bottom: 1px dashed rgb(204, 204, 204); background: transparent; padding-bottom: 0.6em; line-height: 1.6em; }
.btn, .btn .btn-default { background: transparent; color: rgb(184, 191, 198); }
.ty-table-edit { border-top: 1px solid gray; background-color: rgb(54, 59, 64); }
.popover-title { background: transparent; }
.md-image > .md-meta { color: rgb(187, 187, 187); background: transparent; }
.md-expand.md-image > .md-meta { color: rgb(221, 221, 221); }
#write > h3::before, #write > h4::before, #write > h5::before, #write > h6::before { border: none; border-radius: 0px; color: rgb(136, 136, 136); text-decoration: underline; left: -1.4rem; top: 0.2rem; }
#write > h3.md-focus::before { top: 2px; }
#write > h4.md-focus::before { top: 2px; }
.md-toc-item { color: rgb(168, 194, 220); }
#write div.md-toc-tooltip { background-color: rgb(54, 59, 64); }
.dropdown-menu .btn:hover, .dropdown-menu .btn:focus, .md-toc .btn:hover, .md-toc .btn:focus { color: white; background: black; }
#toc-dropmenu { background: rgba(50, 54, 59, 0.93); border: 1px solid rgba(253, 253, 253, 0.15); }
#toc-dropmenu .divider { background-color: rgb(155, 155, 155); }
.outline-expander::before { top: 2px; }
#typora-sidebar { box-shadow: none; border-right: none; }
.sidebar-tabs { border-bottom: 0px; }
#typora-sidebar:hover .outline-title-wrapper { border-left: 1px dashed; }
.outline-title-wrapper .btn { color: inherit; }
.outline-item:hover { border-color: rgb(54, 59, 64); background-color: rgb(54, 59, 64); color: white; }
h1.md-focus .md-attr, h2.md-focus .md-attr, h3.md-focus .md-attr, h4.md-focus .md-attr, h5.md-focus .md-attr, h6.md-focus .md-attr, .md-header-span .md-attr { color: rgb(140, 142, 146); display: inline; }
.md-comment { color: rgb(90, 149, 227); opacity: 1; }
.md-inline-math g, .md-inline-math svg { stroke: rgb(184, 191, 198) !important; fill: rgb(184, 191, 198) !important; }
[md-inline="inline_math"] { color: rgb(156, 178, 233); }
#math-inline-preview .md-arrow::after { background: black; }
.modal-content { background: var(--bg-color); border: 0px; }
.modal-title { font-size: 1.5em; }
.modal-content input { background-color: rgba(26, 21, 21, 0.51); color: white; }
.modal-content .input-group-addon { background-color: rgba(0, 0, 0, 0.17); color: white; }
.modal-backdrop { background-color: rgba(174, 174, 174, 0.7); }
.modal-content .btn-primary { border-color: var(--primary-color); }
.md-table-resize-popover { background-color: rgb(75, 83, 90); }
.form-inline .input-group .input-group-addon { color: white; }
#md-searchpanel { border-bottom: 1px dashed grey; }
.context-menu, #spell-check-panel, #footer-word-count-info { background-color: rgb(66, 70, 74); }
.context-menu.dropdown-menu .divider, .dropdown-menu .divider { background-color: rgb(119, 119, 119); }
footer { color: inherit; }
@media (max-width: 1000px) {
  footer { border-top: none; }
  footer:hover { color: inherit; }
}
#file-info-file-path .file-info-field-value:hover { background-color: rgb(85, 85, 85); color: rgb(222, 222, 222); }
.megamenu-content, .megamenu-opened header { background: var(--bg-color); }
.megamenu-menu-panel h2, .megamenu-menu-panel h1, .long-btn { color: inherit; }
.megamenu-menu-panel input[type="text"] { background: inherit; border-width: 0px 0px 1px; border-top-style: initial; border-right-style: initial; border-left-style: initial; border-color: initial; border-image: initial; border-bottom-style: solid; }
#recent-file-panel-action-btn { background: inherit; border: 1px solid grey; }
.megamenu-menu-panel .dropdown-menu > li > a { color: inherit; background-color: rgb(47, 53, 58); text-decoration: none; }
.megamenu-menu-panel table td:nth-child(1) { color: inherit; font-weight: bold; }
.megamenu-menu-panel tbody tr:hover td:nth-child(1) { color: white; }
.modal-footer .btn-default, .modal-footer .btn-primary, .modal-footer .btn-default:not(:hover) { border: 1px solid transparent; }
.btn-default:hover, .btn-default:focus, .btn-default.focus, .btn-default:active, .btn-default.active, .open > .dropdown-toggle.btn-default { color: white; border: 1px solid rgb(221, 221, 221); background-color: inherit; }
.modal-header { border-bottom: 0px; }
.modal-footer { border-top: 0px; }
#recent-file-panel tbody tr:nth-child(2n-1) { background-color: transparent !important; }
.megamenu-menu-panel tbody tr:hover td:nth-child(2) { color: inherit; }
.megamenu-menu-panel .btn { border: 1px solid rgb(238, 238, 238); background: transparent; }
.mouse-hover .toolbar-icon.btn:hover, #w-full.mouse-hover, #w-pin.mouse-hover { background-color: inherit; }
.typora-node::-webkit-scrollbar { width: 5px; }
.typora-node::-webkit-scrollbar-thumb:vertical { background: rgba(250, 250, 250, 0.3); }
.typora-node::-webkit-scrollbar-thumb:vertical:active { background: rgba(250, 250, 250, 0.5); }
#w-unpin { background-color: rgb(65, 130, 196); }
#top-titlebar, #top-titlebar * { color: var(--item-hover-text-color); }
.typora-sourceview-on #toggle-sourceview-btn, #footer-word-count:hover, .ty-show-word-count #footer-word-count { background: rgb(51, 51, 51); }
#toggle-sourceview-btn:hover { color: rgb(238, 238, 238); background: rgb(51, 51, 51); }
.on-focus-mode .md-end-block:not(.md-focus):not(.md-focus-container) * { color: rgb(104, 104, 104) !important; }
.on-focus-mode .md-end-block:not(.md-focus) img, .on-focus-mode .md-task-list-item:not(.md-focus-container) > input { }
.on-focus-mode li[cid]:not(.md-focus-container) { color: rgb(104, 104, 104); }
.on-focus-mode .md-fences.md-focus .CodeMirror-code > :not(.CodeMirror-activeline) *, .on-focus-mode .CodeMirror.cm-s-inner:not(.CodeMirror-focused) * { color: rgb(104, 104, 104) !important; }
.on-focus-mode .md-focus, .on-focus-mode .md-focus-container { color: rgb(255, 255, 255); }
.on-focus-mode #typora-source .CodeMirror-code > :not(.CodeMirror-activeline) * { color: rgb(104, 104, 104) !important; }
#write .md-focus .md-diagram-panel { border: 1px solid rgb(221, 221, 221); margin-left: -1px; width: calc(100% + 2px); }
#write .md-focus.md-fences-with-lineno .md-diagram-panel { margin-left: auto; }
.md-diagram-panel-error { color: rgb(241, 144, 142); }
.active-tab-files #info-panel-tab-file, .active-tab-files #info-panel-tab-file:hover, .active-tab-outline #info-panel-tab-outline, .active-tab-outline #info-panel-tab-outline:hover { color: rgb(238, 238, 238); }
.sidebar-footer-item:hover, .footer-item:hover { background: inherit; color: white; }
.ty-side-sort-btn.active, .ty-side-sort-btn:hover, .selected-folder-menu-item a::after { color: white; }
#sidebar-files-menu { border: 1px solid; box-shadow: rgba(0, 0, 0, 0.79) 4px 4px 20px; background-color: var(--bg-color); }
.file-list-item { border-bottom: none; }
.file-list-item-summary { opacity: 1; }
.file-list-item.active:first-child { border-top: none; }
.file-node-background { height: 32px; }
.file-library-node.active > .file-node-content, .file-list-item.active { color: var(--active-file-text-color); }
.file-library-node.active > .file-node-background { background-color: var(--active-file-bg-color); }
.file-list-item.active { background-color: var(--active-file-bg-color); }
#ty-tooltip { background-color: black; color: rgb(238, 238, 238); }
.md-task-list-item > input { margin-left: -1.3em; margin-top: 0.3rem; -webkit-appearance: none; }
.md-mathjax-midline { background-color: rgb(87, 97, 107); border-bottom: none; }
footer.ty-footer { border-color: rgb(101, 101, 101); }





 .typora-export li, .typora-export p, .typora-export,  .footnote-line {white-space: normal;} 
</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node'><p><a href="#head"><button style="position: fixed;top:70%;right:0px;background-color:black;" >置<br>顶</button></a></p><p><a id="head"/></p><h1><a href="https://pppenger.github.io/">pppenger.github.io</a></h1><p>目录</p><div class='md-toc' mdtype='toc'><p class="md-toc-content"><span class="md-toc-item md-toc-h3" data-ref="n6"><a class="md-toc-inner" href="#header-n6">Java 与 C++ 的区别</a></span><span class="md-toc-item md-toc-h2" data-ref="n24"><a class="md-toc-inner" href="#header-n24">OOP面向对象编程</a></span><span class="md-toc-item md-toc-h3" data-ref="n27"><a class="md-toc-inner" href="#header-n27">三大特征：</a></span><span class="md-toc-item md-toc-h4" data-ref="n28"><a class="md-toc-inner" href="#header-n28">抽象</a></span><span class="md-toc-item md-toc-h4" data-ref="n30"><a class="md-toc-inner" href="#header-n30">封装</a></span><span class="md-toc-item md-toc-h4" data-ref="n35"><a class="md-toc-inner" href="#header-n35">继承</a></span><span class="md-toc-item md-toc-h4" data-ref="n40"><a class="md-toc-inner" href="#header-n40">多态</a></span><span class="md-toc-item md-toc-h5" data-ref="n42"><a class="md-toc-inner" href="#header-n42">引用多态</a></span><span class="md-toc-item md-toc-h5" data-ref="n44"><a class="md-toc-inner" href="#header-n44">方法多态</a></span><span class="md-toc-item md-toc-h3" data-ref="n59"><a class="md-toc-inner" href="#header-n59">六大原则：</a></span><span class="md-toc-item md-toc-h4" data-ref="n60"><a class="md-toc-inner" href="#header-n60">一、单一职责原则：</a></span><span class="md-toc-item md-toc-h4" data-ref="n63"><a class="md-toc-inner" href="#header-n63">二、开闭原则：</a></span><span class="md-toc-item md-toc-h4" data-ref="n66"><a class="md-toc-inner" href="#header-n66">三、里氏替换原则：</a></span><span class="md-toc-item md-toc-h4" data-ref="n69"><a class="md-toc-inner" href="#header-n69">四、依赖倒置原则：</a></span><span class="md-toc-item md-toc-h4" data-ref="n72"><a class="md-toc-inner" href="#header-n72">五、接口隔离原则：</a></span><span class="md-toc-item md-toc-h4" data-ref="n75"><a class="md-toc-inner" href="#header-n75">六、迪米特原则：</a></span><span class="md-toc-item md-toc-h3" data-ref="n78"><a class="md-toc-inner" href="#header-n78">java访问修饰符</a></span><span class="md-toc-item md-toc-h3" data-ref="n112"><a class="md-toc-inner" href="#header-n112">数据类型</a></span><span class="md-toc-item md-toc-h3" data-ref="n179"><a class="md-toc-inner" href="#header-n179">位运算符</a></span><span class="md-toc-item md-toc-h3" data-ref="n224"><a class="md-toc-inner" href="#header-n224">逻辑运算符</a></span><span class="md-toc-item md-toc-h3" data-ref="n261"><a class="md-toc-inner" href="#header-n261">运算符优先级</a></span><span class="md-toc-item md-toc-h3" data-ref="n266"><a class="md-toc-inner" href="#header-n266">泛型</a></span><span class="md-toc-item md-toc-h3" data-ref="n277"><a class="md-toc-inner" href="#header-n277">static</a></span><span class="md-toc-item md-toc-h4" data-ref="n278"><a class="md-toc-inner" href="#header-n278">Java 中的 static 使用之静态变量</a></span><span class="md-toc-item md-toc-h4" data-ref="n288"><a class="md-toc-inner" href="#header-n288">Java 中的 static 使用之静态方法</a></span><span class="md-toc-item md-toc-h4" data-ref="n305"><a class="md-toc-inner" href="#header-n305">Java 中的 static 使用之静态初始化块</a></span><span class="md-toc-item md-toc-h3" data-ref="n318"><a class="md-toc-inner" href="#header-n318">final关键字</a></span><span class="md-toc-item md-toc-h3" data-ref="n330"><a class="md-toc-inner" href="#header-n330">什么是 Java 中的内部类</a></span><span class="md-toc-item md-toc-h4" data-ref="n353"><a class="md-toc-inner" href="#header-n353">Java 中的成员内部类</a></span><span class="md-toc-item md-toc-h4" data-ref="n372"><a class="md-toc-inner" href="#header-n372">Java 中的静态内部类</a></span><span class="md-toc-item md-toc-h4" data-ref="n380"><a class="md-toc-inner" href="#header-n380">Java 中的方法内部类</a></span><span class="md-toc-item md-toc-h3" data-ref="n387"><a class="md-toc-inner" href="#header-n387">引用类型转换</a></span><span class="md-toc-item md-toc-h3" data-ref="n392"><a class="md-toc-inner" href="#header-n392">接口interface</a></span><span class="md-toc-item md-toc-h4" data-ref="n396"><a class="md-toc-inner" href="#header-n396">匿名内部类</a></span><span class="md-toc-item md-toc-h2" data-ref="n409"><a class="md-toc-inner" href="#header-n409">Java API 简介</a></span><span class="md-toc-item md-toc-h2" data-ref="n414"><a class="md-toc-inner" href="#header-n414">java.lang 包</a></span><span class="md-toc-item md-toc-h3" data-ref="n443"><a class="md-toc-inner" href="#header-n443">一、String</a></span><span class="md-toc-item md-toc-h4" data-ref="n446"><a class="md-toc-inner" href="#header-n446">0.java中String new和直接赋值的区别</a></span><span class="md-toc-item md-toc-h4" data-ref="n475"><a class="md-toc-inner" href="#header-n475">1.Java 中 String 类的常用方法 Ⅰ</a></span><span class="md-toc-item md-toc-h4" data-ref="n489"><a class="md-toc-inner" href="#header-n489">2.Java 中的 String 类常用方法 Ⅱ</a></span><span class="md-toc-item md-toc-h4" data-ref="n497"><a class="md-toc-inner" href="#header-n497">3.java中字符串和字符数组的转换？</a></span><span class="md-toc-item md-toc-h4" data-ref="n500"><a class="md-toc-inner" href="#header-n500">4.StringBuilder 和StringBuffer</a></span><span class="md-toc-item md-toc-h5" data-ref="n503"><a class="md-toc-inner" href="#header-n503">StringBuffer</a></span><span class="md-toc-item md-toc-h5" data-ref="n560"><a class="md-toc-inner" href="#header-n560">StringBuilder </a></span><span class="md-toc-item md-toc-h3" data-ref="n569"><a class="md-toc-inner" href="#header-n569">Java 中基本类型和字符串之间的转换</a></span><span class="md-toc-item md-toc-h4" data-ref="n583"><a class="md-toc-inner" href="#header-n583">valueOf与parseInt方法</a></span><span class="md-toc-item md-toc-h3" data-ref="n592"><a class="md-toc-inner" href="#header-n592">二、包装类</a></span><span class="md-toc-item md-toc-h4" data-ref="n593"><a class="md-toc-inner" href="#header-n593">1.Integer 类</a></span><span class="md-toc-item md-toc-h4" data-ref="n649"><a class="md-toc-inner" href="#header-n649">2.Character 类</a></span><span class="md-toc-item md-toc-h4" data-ref="n681"><a class="md-toc-inner" href="#header-n681">3.Boolean 类</a></span><span class="md-toc-item md-toc-h3" data-ref="n716"><a class="md-toc-inner" href="#header-n716">三、Math</a></span><span class="md-toc-item md-toc-h3" data-ref="n783"><a class="md-toc-inner" href="#header-n783">四、类 Class</a></span><span class="md-toc-item md-toc-h3" data-ref="n795"><a class="md-toc-inner" href="#header-n795">五、反射</a></span><span class="md-toc-item md-toc-h3" data-ref="n825"><a class="md-toc-inner" href="#header-n825">六、注解Annotation</a></span><span class="md-toc-item md-toc-h5" data-ref="n833"><a class="md-toc-inner" href="#header-n833">注解的用处：</a></span><span class="md-toc-item md-toc-h5" data-ref="n835"><a class="md-toc-inner" href="#header-n835">注解的原理：</a></span><span class="md-toc-item md-toc-h5" data-ref="n837"><a class="md-toc-inner" href="#header-n837">元注解：</a></span><span class="md-toc-item md-toc-h5" data-ref="n840"><a class="md-toc-inner" href="#header-n840">常见标准的Annotation：</a></span><span class="md-toc-item md-toc-h3" data-ref="n843"><a class="md-toc-inner" href="#header-n843">七、Object类</a></span><span class="md-toc-item md-toc-h4" data-ref="n869"><a class="md-toc-inner" href="#header-n869">toString()方法</a></span><span class="md-toc-item md-toc-h4" data-ref="n872"><a class="md-toc-inner" href="#header-n872">equals和==的区别</a></span><span class="md-toc-item md-toc-h2" data-ref="n879"><a class="md-toc-inner" href="#header-n879">java日期和随机数</a></span><span class="md-toc-item md-toc-h3" data-ref="n881"><a class="md-toc-inner" href="#header-n881">一、java.util 和 java.time 包介绍</a></span><span class="md-toc-item md-toc-h3" data-ref="n886"><a class="md-toc-inner" href="#header-n886">二、Date 类和Calendar 类</a></span><span class="md-toc-item md-toc-h3" data-ref="n910"><a class="md-toc-inner" href="#header-n910">三、java.time 包</a></span><span class="md-toc-item md-toc-h3" data-ref="n918"><a class="md-toc-inner" href="#header-n918">四、Random 类</a></span><span class="md-toc-item md-toc-h2" data-ref="n942"><a class="md-toc-inner" href="#header-n942">Java 集合框架</a></span><span class="md-toc-item md-toc-h3" data-ref="n944"><a class="md-toc-inner" href="#header-n944">一、Collection 接口</a></span><span class="md-toc-item md-toc-h3" data-ref="n1012"><a class="md-toc-inner" href="#header-n1012">二、Map接口</a></span><span class="md-toc-item md-toc-h3" data-ref="n1080"><a class="md-toc-inner" href="#header-n1080">三、List 接口与 ArrayList 类</a></span><span class="md-toc-item md-toc-h3" data-ref="n1140"><a class="md-toc-inner" href="#header-n1140">四、Set 接口和 HashSet 类</a></span><span class="md-toc-item md-toc-h3" data-ref="n1147"><a class="md-toc-inner" href="#header-n1147">五、Quere接口</a></span><span class="md-toc-item md-toc-h3" data-ref="n1150"><a class="md-toc-inner" href="#header-n1150">五、HashSet和HashMap的区别</a></span><span class="md-toc-item md-toc-h3" data-ref="n1172"><a class="md-toc-inner" href="#header-n1172">六、HashMap 类</a></span><span class="md-toc-item md-toc-h3" data-ref="n1198"><a class="md-toc-inner" href="#header-n1198">七、HashTable</a></span><span class="md-toc-item md-toc-h3" data-ref="n1207"><a class="md-toc-inner" href="#header-n1207">八、ConcurrentHashMap的实现——JDK7版本</a></span><span class="md-toc-item md-toc-h3" data-ref="n1218"><a class="md-toc-inner" href="#header-n1218">九、JDK8中的ConcurrentHashMap</a></span><span class="md-toc-item md-toc-h3" data-ref="n1222"><a class="md-toc-inner" href="#header-n1222">十、ConcurrentHashMap总结</a></span><span class="md-toc-item md-toc-h3" data-ref="n1236"><a class="md-toc-inner" href="#header-n1236">十一、结合Util工具包</a></span><span class="md-toc-item md-toc-h2" data-ref="n1243"><a class="md-toc-inner" href="#header-n1243">Java io</a></span><span class="md-toc-item md-toc-h3" data-ref="n1250"><a class="md-toc-inner" href="#header-n1250">一、字节流</a></span><span class="md-toc-item md-toc-h4" data-ref="n1251"><a class="md-toc-inner" href="#header-n1251">1、基类：InputStream 和 OutputStream</a></span><span class="md-toc-item md-toc-h4" data-ref="n1287"><a class="md-toc-inner" href="#header-n1287">2、文件流</a></span><span class="md-toc-item md-toc-h4" data-ref="n1302"><a class="md-toc-inner" href="#header-n1302">3、缓冲流（速度快）</a></span><span class="md-toc-item md-toc-h4" data-ref="n1312"><a class="md-toc-inner" href="#header-n1312">4、 数据流</a></span><span class="md-toc-item md-toc-h4" data-ref="n1323"><a class="md-toc-inner" href="#header-n1323">5、标准流、内存读写流、顺序输入流</a></span><span class="md-toc-item md-toc-h3" data-ref="n1339"><a class="md-toc-inner" href="#header-n1339">二、字符流</a></span><span class="md-toc-item md-toc-h4" data-ref="n1340"><a class="md-toc-inner" href="#header-n1340">1、基类：Reader 和 Writer</a></span><span class="md-toc-item md-toc-h4" data-ref="n1399"><a class="md-toc-inner" href="#header-n1399">2、InputStreamReader 和 OutputStreamWriter</a></span><span class="md-toc-item md-toc-h4" data-ref="n1405"><a class="md-toc-inner" href="#header-n1405">3、缓存流</a></span><span class="md-toc-item md-toc-h4" data-ref="n1414"><a class="md-toc-inner" href="#header-n1414">4、其它字符流类</a></span><span class="md-toc-item md-toc-h3" data-ref="n1433"><a class="md-toc-inner" href="#header-n1433">三、File文件操作</a></span><span class="md-toc-item md-toc-h3" data-ref="n1441"><a class="md-toc-inner" href="#header-n1441">四、RandomAccessFile类</a></span><span class="md-toc-item md-toc-h3" data-ref="n1480"><a class="md-toc-inner" href="#header-n1480">五、Serializable（序列化）</a></span><span class="md-toc-item md-toc-h1" data-ref="n1483"><a class="md-toc-inner" href="#header-n1483">Java并发性和多线程</a></span><span class="md-toc-item md-toc-h3" data-ref="n1484"><a class="md-toc-inner" href="#header-n1484">进程</a></span><span class="md-toc-item md-toc-h3" data-ref="n1494"><a class="md-toc-inner" href="#header-n1494">并行和并发</a></span><span class="md-toc-item md-toc-h3" data-ref="n1514"><a class="md-toc-inner" href="#header-n1514">线程和进程的区别？</a></span><span class="md-toc-item md-toc-h2" data-ref="n1528"><a class="md-toc-inner" href="#header-n1528">线程</a></span><span class="md-toc-item md-toc-h3" data-ref="n1529"><a class="md-toc-inner" href="#header-n1529">线程状态</a></span><span class="md-toc-item md-toc-h3" data-ref="n1585"><a class="md-toc-inner" href="#header-n1585">线程的使用</a></span><span class="md-toc-item md-toc-h4" data-ref="n1604"><a class="md-toc-inner" href="#header-n1604">run()和start()方法区别：</a></span><span class="md-toc-item md-toc-h3" data-ref="n1615"><a class="md-toc-inner" href="#header-n1615">与线程生命周期相关的<strong>方法</strong></a></span><span class="md-toc-item md-toc-h5" data-ref="n1616"><a class="md-toc-inner" href="#header-n1616">一、sleep</a></span><span class="md-toc-item md-toc-h6" data-ref="n1619"><a class="md-toc-inner" href="#header-n1619"><strong>wait() 和 sleep() 的区别</strong></a></span><span class="md-toc-item md-toc-h5" data-ref="n1625"><a class="md-toc-inner" href="#header-n1625">二、yield方法</a></span><span class="md-toc-item md-toc-h5" data-ref="n1630"><a class="md-toc-inner" href="#header-n1630">三、join方法</a></span><span class="md-toc-item md-toc-h5" data-ref="n1632"><a class="md-toc-inner" href="#header-n1632">四、interrupt方法</a></span><span class="md-toc-item md-toc-h6" data-ref="n1642"><a class="md-toc-inner" href="#header-n1642">InterruptedException</a></span><span class="md-toc-item md-toc-h3" data-ref="n1648"><a class="md-toc-inner" href="#header-n1648">线程池</a></span><span class="md-toc-item md-toc-h3" data-ref="n1666"><a class="md-toc-inner" href="#header-n1666">synchronized</a></span><span class="md-toc-item md-toc-h5" data-ref="n1667"><a class="md-toc-inner" href="#header-n1667">1. 同步一个代码块</a></span><span class="md-toc-item md-toc-h5" data-ref="n1674"><a class="md-toc-inner" href="#header-n1674">2. 同步一个方法</a></span><span class="md-toc-item md-toc-h5" data-ref="n1677"><a class="md-toc-inner" href="#header-n1677">3. 同步一个类</a></span><span class="md-toc-item md-toc-h5" data-ref="n1681"><a class="md-toc-inner" href="#header-n1681">4. 同步一个静态方法</a></span><span class="md-toc-item md-toc-h3" data-ref="n1685"><a class="md-toc-inner" href="#header-n1685">Lock显式锁</a></span><span class="md-toc-item md-toc-h3" data-ref="n1698"><a class="md-toc-inner" href="#header-n1698">synchronized锁和Lock锁使用哪个</a></span><span class="md-toc-item md-toc-h3" data-ref="n1728"><a class="md-toc-inner" href="#header-n1728">线程之间的协作wait() notify() notifyAll()</a></span><span class="md-toc-item md-toc-h3" data-ref="n1739"><a class="md-toc-inner" href="#header-n1739">await() signal() signalAll()</a></span><span class="md-toc-item md-toc-h3" data-ref="n1744"><a class="md-toc-inner" href="#header-n1744">J.U.C - AQS</a></span><span class="md-toc-item md-toc-h4" data-ref="n1758"><a class="md-toc-inner" href="#header-n1758">信号量</a></span><span class="md-toc-item md-toc-h5" data-ref="n1759"><a class="md-toc-inner" href="#header-n1759">CountDownLatch</a></span><span class="md-toc-item md-toc-h5" data-ref="n1762"><a class="md-toc-inner" href="#header-n1762">CyclicBarrier</a></span><span class="md-toc-item md-toc-h5" data-ref="n1767"><a class="md-toc-inner" href="#header-n1767">Semaphore</a></span><span class="md-toc-item md-toc-h3" data-ref="n1771"><a class="md-toc-inner" href="#header-n1771">ThreadLocal</a></span><span class="md-toc-item md-toc-h3" data-ref="n1775"><a class="md-toc-inner" href="#header-n1775">原子性</a></span><span class="md-toc-item md-toc-h3" data-ref="n1778"><a class="md-toc-inner" href="#header-n1778">可见性</a></span><span class="md-toc-item md-toc-h3" data-ref="n1784"><a class="md-toc-inner" href="#header-n1784">volatile</a></span><span class="md-toc-item md-toc-h3" data-ref="n1801"><a class="md-toc-inner" href="#header-n1801">线程安全</a></span><span class="md-toc-item md-toc-h4" data-ref="n1804"><a class="md-toc-inner" href="#header-n1804">不可变</a></span><span class="md-toc-item md-toc-h4" data-ref="n1817"><a class="md-toc-inner" href="#header-n1817">非阻塞同步</a></span><span class="md-toc-item md-toc-h4" data-ref="n1820"><a class="md-toc-inner" href="#header-n1820">无同步方案</a></span></p></div><h3><a name='header-n6' class='md-header-anchor '></a>Java 与 C++ 的区别</h3><ul><li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li><li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li><li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li><li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li><li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li><li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li><li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li><li>Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。</li></ul><h2><a name='header-n24' class='md-header-anchor '></a>OOP面向对象编程</h2><p>把计算机中的东西比喻成现实生活中的一样事物，一个对象。那现实生活中的对象都会有属性跟行为，这就对应着计算机中的属性和方法（函数）。 </p><p>OOP就是我们不是一个流程走到底，而是直接操作多个对象来实现想做的任务。</p><h3><a name='header-n27' class='md-header-anchor '></a>三大特征：</h3><h4><a name='header-n28' class='md-header-anchor '></a>抽象</h4><p>我们在<strong>定义一个类</strong>的时候，实际上就是把一类事物的公有的属性和行为提取出来，形成一个物理模型，这种研究问题的方法称为抽象。</p><h4><a name='header-n30' class='md-header-anchor '></a>封装</h4><p>1.概念：将类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问</p><p>2.好处：</p><p>a.只能通过规定的方法访问数据</p><p>b.隐藏类的实例细节，方便修改和实现</p><h4><a name='header-n35' class='md-header-anchor '></a>继承</h4><p>继承可以解决代码复用问题，让我们编程更加靠近人类的思维，当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类（比如刚才的Student），在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extend语句来声明继承 父类：</p><p>class 子类 extends 父类  这样，子类就会自动拥有父类定义的属性和方法。</p><p>继承注意事项：</p><p>子类最多继承一个父类
java多有类都是Object类的子类</p><h4><a name='header-n40' class='md-header-anchor '></a>多态</h4><p>所谓多态，就是指一个引用（类型）在不同情况下的多种状态，你也可以这样理解：多态是指通过指向父类的指针，来调用在不同子类中实现的方法</p><h5><a name='header-n42' class='md-header-anchor '></a>引用多态</h5><p>父类的引用可以指向本类的对象
父类的引用可以指向子类的对象</p><h5><a name='header-n44' class='md-header-anchor '></a>方法多态</h5><p>创建本类对象时，调用的方法为本类方法
创建子类对象时，调用的方法为之类重写的方法或者继承的方法</p><p><strong>方法重载：</strong></p><p>简单地说：方法重载就是类的同一种功能的多种实现方式，到底采用哪种方式，取决于调用者给出的参数。</p><p>方法重载-注意事项</p><p>1.<strong>方法名相同</strong></p><p>2.<strong>方法的参数类型、个数、顺序至少有一项不同</strong></p><p>3.<strong>仅仅是返回类型不一样，是不能构成重载的</strong></p><p>4.<strong>方法修饰符可以不同</strong></p><p>5.<strong>如果只是控制访问符不同</strong>，不能构成重载</p><p><strong>方法覆盖：</strong></p><p>将父类的方法进行重新写。方法的覆盖就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么我们就说子类的这个方法覆盖了父类的那个方法，比如上个案例的Cat类中的cry方法就覆盖了Animal类的cry方法。</p><p>方法覆盖的注意事项：</p><p>（1）子类的方法的返回类型，参数，方法名称，要和父类方法的返回类型，参数，方法名称完全一样，否则编译出错。</p><p>（2）子类方法不能缩小父类方法的访问权限。（假设父类方法时public，但是你的子类方法改成了protected，这样就会出现报错）</p><h3><a name='header-n59' class='md-header-anchor '></a>六大原则：</h3><h4><a name='header-n60' class='md-header-anchor '></a>一、单一职责原则：</h4><p>单一职责原则的定义是就一个类而言，应该仅有一个引起他变化的原因。也就是说一个类应该只负责一件事情。</p><p>比如：我们在写一个简单画图板时，一般把画图板界面与画图板上的监听器分成两个类去完成。这样的好处比如我们只想改变画图板界面时，监听器类就可以直接调用，不必重新编写。可以降低类的复杂性，提高类的可读性和系统的维护性。</p><h4><a name='header-n63' class='md-header-anchor '></a>二、开闭原则：</h4><p>开闭原则的定义是软件中的对象(类，模块，函数等)应该对于扩展是开放的，但是对于修改是关闭的。</p><p>比如对person父类中有很多方法，但想在增加study的方法时，不要直接在父类中修改，可以在student子类中扩展study方法。这样可以提高方法的复用性和系统的维护性。</p><h4><a name='header-n66' class='md-header-anchor '></a>三、里氏替换原则：</h4><p>简单来说就是子类可以扩展父类功能，但是不能改变其原有的功能。可以有以下这些理解：</p><p>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。
子类可以增加自己独有的方法。
当子类的方法重载父类的方法时候，方法的形参要比父类的方法的输入参数更加宽松。
当子类的方法实现父类的抽象方法时，方法的返回值要比父类更严格。</p><h4><a name='header-n69' class='md-header-anchor '></a>四、依赖倒置原则：</h4><p>依赖倒置原则（Dependence Inversion Principle,DIP），原始定义包含三层含义：<strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象</strong>。 </p><p>比如：有一个奔驰类，在person类中调用其方法可以实现驾驶奔驰，但却无法驾驶宝马，所以最好的办法是写一个汽车接口，这样可以让不同品牌的汽车来实现它，person类中就可以通过调用实现好的类来驾驶不同汽车。</p><h4><a name='header-n72' class='md-header-anchor '></a>五、接口隔离原则：</h4><p>接口隔离原则的定义是客户端不应该依赖他不需要的接口。</p><p>比如：一个work接口中有teach和study两个抽象方法，而对于teacher来说只用teach方法，却也要把study方法实现一遍，这样代码就会冗余，并增加程序运行负担，因此应该把teach和study方法分别写成两个接口。这样可以提高代码的灵活性。</p><h4><a name='header-n75' class='md-header-anchor '></a>六、迪米特原则：</h4><p>迪米特原则也被称为最小知识原则，他的定义一个对象应该对其他对象保持最小的了解。简单的理解就是高内聚,低耦合，一个类尽量减少对其他对象的依赖，并且这个类的方法和属性能用私有的就尽量私有化.</p><p>&nbsp;</p><h3><a name='header-n78' class='md-header-anchor '></a>java访问修饰符</h3><figure><table><thead><tr><th>访问修饰符</th><th>本类</th><th>同包</th><th>子类</th><th>其他</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>默认</td><td>√</td><td>√</td><td>&nbsp;</td><td>&nbsp;</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>&nbsp;</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n112' class='md-header-anchor '></a>数据类型</h3><p>Java 中一共八种基本数据类型，下表列出了基本数据类型的数据范围、存储格式、默认值、包装类型等。</p><figure><table><thead><tr><th>数据类型</th><th>默认值</th><th>存储格式</th><th>数据范围</th><th>包装类型</th></tr></thead><tbody><tr><td>short</td><td>0</td><td>2 个字节</td><td>-32,768 到 32767</td><td>Short</td></tr><tr><td>int</td><td>0</td><td>4 个字节</td><td>-2,147,483,648 到 2,147,483,647</td><td>Integer</td></tr><tr><td>byte</td><td>0</td><td>1 个字节</td><td>-128 到 127</td><td>Byte</td></tr><tr><td>char</td><td>空</td><td>2 个字节</td><td>Unicode 的字符范围：’\u0000’（即为 0）到’\uffff’（即为 65,535）</td><td>Character</td></tr><tr><td>long</td><td>0L 或 0l</td><td>8 个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036, 854,775,807</td><td>Long</td></tr><tr><td>float</td><td>0.0F 或 0.0f</td><td>4 个字节</td><td>32 位 IEEEE-754 单精度范围</td><td>Float</td></tr><tr><td>double</td><td>0.0 或 0.0D(d)</td><td>8 个字节</td><td>64 位 IEEE-754 双精度范围</td><td>Double</td></tr><tr><td>boolean</td><td>false</td><td>1 位</td><td>true 或 false</td><td>Boolean</td></tr></tbody></table></figure><p><strong>整数</strong></p><p>byte、short、int、long 四种基本数据类型表示整数，需要注意的是 long 类型，使用 long 修饰的变量需要在数值后面加上 L 或者 l，比如<code>long num=1L;</code>，一般使用大写 L，为了避免小写 l 与数值 1 混淆。</p><p><strong>浮点数</strong></p><p>float 和 double 类型表示浮点数，即可以表示小数部分。需要注意的是 float 类型的数值后面需要加上 F 或者 f，否则会被当成 double 类型处理。double 类型的数值可以加上 D 或 d，也可以不加。</p><p><strong>char</strong> <strong>类型</strong></p><p>char 类型用于表示单个字符。需要将字符用单引号括起来<code>char a=&#39;a&#39;</code>，char 可以和整数互相转换，如果字符<code>a</code>也可以写成<code>char a=97</code>。也可以用十六进制表示<code>char a = &#39;\u0061&#39;</code>。</p><p><strong>boolean</strong> <strong>类型</strong></p><p>boolean 类型（布尔类型）用于表示真值<code>true</code>或者假值<code>false</code>，Java 中布尔值不能和整数类型或者其它类型互相转换。</p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n179' class='md-header-anchor '></a>位运算符</h3><p>Java 定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。位运算时先转换为二进制，再按位运算。</p><p>表格中的例子中，变量<code>a</code>的值为 60(00111100)，变量<code>b</code>(00001101)的值为 13：</p><figure><table><thead><tr><th>位运算符</th><th>名称</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与</td><td>如果相对应位都是 1，则结果为 1，否则为 0</td><td>（a＆b），得到 12，即 0000 1100</td></tr><tr><td>丨</td><td>按位或</td><td>如果相对应位都是 0，则结果为 0，否则为 1</td><td>（ a 丨 b ）得到 61，即 0011 1101</td></tr><tr><td>^</td><td>按位异或</td><td>如果相对应位值相同，则结果为 0，否则为 1</td><td>（a^b）得到 49，即 0011 0001</td></tr><tr><td>~</td><td>按位补</td><td>翻转操作数的每一位，即 0 变成 1，1 变成 0</td><td>（〜a）得到-61，即 1100 0011</td></tr><tr><td>&lt;&lt;</td><td>按位左移</td><td>左操作数按位左移右操作数指定的位数</td><td>a&lt;&lt;2 得到 240，即 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>按位右移</td><td>左操作数按位右移右操作数指定的位数</td><td>a&gt;&gt;2 得到 15 即 1111</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零</td><td>左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充</td><td>a&gt;&gt;&gt;2 得到 15 即 0000 1111</td></tr></tbody></table></figure><p>&nbsp;</p><h3><a name='header-n224' class='md-header-anchor '></a>逻辑运算符</h3><p>逻辑运算符是通过运算符将操作数或等式进行逻辑判断的语句。</p><p>表格中的例子中，假设布尔变量 a 为真，变量 b 为假：</p><figure><table><thead><tr><th>逻辑运算符</th><th>名称</th><th>描述</th><th>类型</th><th>举例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与</td><td>当且仅当两个操作数都为真，条件才为真</td><td>双目运算符</td><td>（a &amp;&amp; b）为假</td></tr><tr><td>｜｜</td><td>或</td><td>两个操作数任何一个为真，条件为真</td><td>双目运算符</td><td>（a ｜｜ b）为真</td></tr><tr><td>！</td><td>非</td><td>用来反转操作数的逻辑状态。如果条件为真，则逻辑非运算符将得到假</td><td>单目运算符</td><td>（!a）为假</td></tr><tr><td>^</td><td>异或</td><td>如果两个操作数逻辑相同，则结果为假，否则为真</td><td>双目运算符</td><td>（a ^ b）为真</td></tr></tbody></table></figure><p><strong>当使用<code>&amp;&amp;(与)</code>逻辑运算符时，在两个操作数都为 true 时，结果才为 true，但是当得到第一个操作为 false 时，其结果就必定是 false，这时候就不会再判断第二个操作了。</strong> </p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n261' class='md-header-anchor '></a>运算符优先级</h3><p>运算符的优先级是帮助我们在一个表达式中如何对于不同的运算符和相同的运算符，进行正确的运算顺序。</p><p>运算符的优先级不需要特别地去记忆它，比较复杂的表达式一般使用圆括号<code>()</code>分开，提高可读性。</p><p>!<img src='https://doc.shiyanlou.com/document-uid79144labid1050timestamp1434082078141.png/wm' alt='运算符的优先级' referrerPolicy='no-referrer' /></p><p><img src='https://doc.shiyanlou.com/document-uid79144labid1050timestamp1434082102195.png/wm' alt='运算符的优先级2' referrerPolicy='no-referrer' /></p><h3><a name='header-n266' class='md-header-anchor '></a>泛型</h3><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class Box&lt;T&gt; {</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  // T stands for "Type"</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  private T t;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  public void set(T t) { this.t = t; }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  public T get() { return t; }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 156px;"></div><div class="CodeMirror-gutters" style="display: none; height: 156px;"></div></div></div></pre><p> <strong>Java中的泛型是什么 ? 使用泛型的好处是什么?</strong></p><p>　　【概括：避免了强转，提供了编译期的类型安全】这是在各种Java泛型面试中，一开场你就会被问到的问题中的一个，主要集中在初级和中级面试中。那些拥有Java1.4或更早版本的开发背景的人都知道，在集合中存储对象并在使用前进行类型转换是多么的不方便。泛型防止了那种情况的发生。它提供了编译期的类型安全，确保你只能把正确类型的对象放入集合中，避免了在运行时出现ClassCastException。</p><p><strong>Java的泛型是如何工作的 ? 什么是类型擦除 ?</strong></p><p>　　【在运行时擦出了类型的相关信息】泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。例如List<String>在运行时仅用一个List来表示。这样做的目的，是确保能和Java 5之前的版本开发二进制类库进行兼容。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。</p><p><strong>什么是泛型中的限定通配符和非限定通配符 ?</strong></p><p>　　限定通配符对类型进行了限制。<strong>有两种限定通配符</strong>，一种是<? extends T>它通过确保类型必须是T的子类来设定类型的上界，另一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面**<?>表示了非限定通配符**，因为&lt;?&gt;可以用任意类型来替代。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n277' class='md-header-anchor '></a>static</h3><h4><a name='header-n278' class='md-header-anchor '></a>Java 中的 static 使用之静态变量</h4><p><font size=3>Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。当然，鉴于他作用的特殊性更推荐用类名访问~~</font></p><p>使用 static 可以修饰变量、方法和代码块。</p><p>例如，我们在类中定义了一个 静态变量 hobby ，操作代码如下所示：</p><p><a href='http://img.mukewang.com/5392d47b0001571708530473.jpg'><img src='http://img.mukewang.com/5392d47b0001571708530473.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果：<a href='http://img.mukewang.com/5392d4a4000133c002950084.jpg'><img src='http://img.mukewang.com/5392d4a4000133c002950084.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p><strong>注意：</strong>静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收！~~</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n288' class='md-header-anchor '></a>Java 中的 static 使用之静态方法</h4><p>与静态变量一样，我们也可以使用 static 修饰方法，称为静态方法或类方法。其实之前我们一直写的 main 方法就是静态方法。静态方法的使用如：</p><p><a href='http://img.mukewang.com/539137150001c96c08220542.jpg'><img src='http://img.mukewang.com/539137150001c96c08220542.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果：<a href='http://img.mukewang.com/5391358100013f8502330076.jpg'><img src='http://img.mukewang.com/5391358100013f8502330076.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>需要注意：</p><p>1、 <strong>静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。</strong>如：</p><p><a href='http://img.mukewang.com/5392d6eb0001283007020239.jpg'><img src='http://img.mukewang.com/5392d6eb0001283007020239.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p><strong>如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量</strong>。如：</p><p><a href='http://img.mukewang.com/5392d7390001a10806150193.jpg'><img src='http://img.mukewang.com/5392d7390001a10806150193.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>2、 <strong>在普通成员方法中，则可以直接访问同类的非静态变量和静态变量</strong>，如下所示：</p><p><a href='http://img.mukewang.com/5392d78e000155c305470193.jpg'><img src='http://img.mukewang.com/5392d78e000155c305470193.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>3、 <strong>静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。</strong>如：</p><p><a href='http://img.mukewang.com/53a3fb160001d04a04910345.jpg'><img src='http://img.mukewang.com/53a3fb160001d04a04910345.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n305' class='md-header-anchor '></a>Java 中的 static 使用之静态初始化块</h4><p>Java 中可以通过初始化块进行数据赋值。如：</p><p><a href='http://img.mukewang.com/5392da9600010e5503680168.jpg'><img src='http://img.mukewang.com/5392da9600010e5503680168.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>在类的声明中，可以包含多个初始化块，当创建类的实例时，就会依次执行这些代码块。如果使用 static 修饰初始化块，就称为静态初始化块。</p><p>需要特别注意：<strong>静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量</strong>。</p><p>我们来看一段代码：</p><p><a href='http://img.mukewang.com/53941e320001fdd507670575.jpg'><img src='http://img.mukewang.com/53941e320001fdd507670575.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果：</p><p><a href='http://img.mukewang.com/53941e880001cb8003530223.jpg'><img src='http://img.mukewang.com/53941e880001cb8003530223.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>通过输出结果，我们可以看到，程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法。由于静态初始化块只在类加载时执行一次，所以当再次创建对象 hello2 时并未执行静态初始化块。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n318' class='md-header-anchor '></a>final关键字</h3><p>final可以修饰类、方法、属性和变量</p><p>final修饰类，则该类不允许被继承</p><p>final修饰方法，则改方法不允许被覆盖(重写)</p><p>final修饰属性</p><p><span>		</span>则该类的属性不可修改且不会进行隐式自动初始化</p><p><span>		</span>或在构造方法中赋值（只能选其一）</p><p>final修饰变量，变量不可修改，只能赋值一次，即变为常量</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n330' class='md-header-anchor '></a>什么是 Java 中的内部类</h3><p><strong>问：什么是内部类呢？</strong></p><p>答：内部类（ Inner Class ）就是定义在另外一个类里面的类。与之对应，包含内部类的类被称为外部类。</p><p><strong>问：那为什么要将一个类定义在另一个类里面呢？清清爽爽的独立的一个类多好啊！！</strong></p><p>答：内部类的主要作用如下：</p><ol start='' ><li>内部类提供了更好的封装，可以把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类</li><li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据</li><li>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便</li></ol><p><strong>问：内部类有几种呢？</strong></p><p>答：内部类可分为以下几种：</p><ul><li>成员内部类</li><li>静态内部类</li><li>方法内部类</li><li>匿名内部类</li></ul><h4><a name='header-n353' class='md-header-anchor '></a>Java 中的成员内部类</h4><p>内部类中最常见的就是成员内部类，也称为普通内部类。我们来看如下代码：</p><p><a href='http://img.mukewang.com/539e60d80001223908320512.jpg'><img src='http://img.mukewang.com/539e60d80001223908320512.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果为：<a href='http://img.mukewang.com/539e60f70001b89302170050.jpg'><img src='http://img.mukewang.com/539e60f70001b89302170050.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>从上面的代码中我们可以看到，<strong>成员内部类的使用方法</strong>：</p><p>1、 Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，如 public 、 protected 、 private 等</p><p>2、 Inner 类中定义的 test() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，如直接访问 Outer 类中的私有属性a</p><p>3、 定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，即：内部类 对象名 = 外部类对象.new 内部类( );</p><p>4、 编译上面的程序后，会发现产生了两个 .class 文件</p><p><a href='http://img.mukewang.com/53a004590001164004560040.jpg'><img src='http://img.mukewang.com/53a004590001164004560040.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>其中，第二个是外部类的 .class 文件，第一个是内部类的 .class 文件，即成员内部类的 .class 文件总是这样：外部类名$内部类名.class</p><p>另外，<strong>友情提示哦：</strong></p><p>1、 外部类是不能直接使用内部类的成员和方法滴</p><p><a href='http://img.mukewang.com/54641b6300012da606460299.jpg'><img src='http://img.mukewang.com/54641b6300012da606460299.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法。</p><p>2、 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字。如：</p><p><a href='http://img.mukewang.com/539e638b0001ab1208200295.jpg'><img src='http://img.mukewang.com/539e638b0001ab1208200295.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果：<a href='http://img.mukewang.com/539e63d400016cf101960050.jpg'><img src='http://img.mukewang.com/539e63d400016cf101960050.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>&nbsp;</p><h4><a name='header-n372' class='md-header-anchor '></a>Java 中的静态内部类</h4><p>静态内部类是 static 修饰的内部类，这种内部类的特点是：</p><p>1、 静态内部类不能直接访问外部类的非静态成员，但可以通过 <strong>new 外部类().成员</strong> 的方式访问 </p><p>2、 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员</p><p>3、 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 <strong>内部类 对象名= new 内部类();</strong></p><p><a href='http://img.mukewang.com/539e948a0001a71007630511.jpg'><img src='http://img.mukewang.com/539e948a0001a71007630511.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果 ： <a href='http://img.mukewang.com/539e94a500014f0101930052.jpg'><img src='http://img.mukewang.com/539e94a500014f0101930052.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>&nbsp;</p><h4><a name='header-n380' class='md-header-anchor '></a>Java 中的方法内部类</h4><p>方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。</p><p><a href='http://img.mukewang.com/539ea96700013ca708200621.jpg'><img src='http://img.mukewang.com/539ea96700013ca708200621.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p><strong>一定要注意哦：</strong>由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n387' class='md-header-anchor '></a>引用类型转换</h3><p>1.向上类型转换（隐式/自动类型转换），是小类型到大类型的转换</p><p>2.向下类型转换（强制类型转换），是大类型到小类型</p><p>3.instanceof运算符（判断前面是否包含后面），来解决引用对象的类型，避免类型转换的安全性问题</p><p>&nbsp;</p><h3><a name='header-n392' class='md-header-anchor '></a>接口interface</h3><p>必选加sbstract关键字，默认有加</p><p><strong>接口可以多继承父类，但类只能单继承</strong>
<strong>一个类可以实现一个或多个接口</strong></p><p>常量：接口中的属性是常量，即使定义时不添加public static final修饰符，系统也会自动加上
方法：只能是抽象方法，不加public static修饰符，系统也会自动加上</p><h4><a name='header-n396' class='md-header-anchor '></a>匿名内部类</h4><p>没有名字的内部类，一般不关注类的名称只关注实现</p><p>语法：</p><p><code>Interface i=new Interface(){</code></p><p><code>public void method(){...};</code></p><p><code>}</code></p><p><code>i.method</code></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n409' class='md-header-anchor '></a>Java API 简介</h2><p>Java 的核心 API 是非常庞大的，这给开发者来说带来了很大的方便。所谓的 API 就是一些已经写好、可直接调用的类库。Java 里有非常庞大的 API，其中有一些类库是我们必须得掌握的，只有熟练掌握了 Java 一些核心的 API，我们才能更好的使用 Java。</p><p><img src='https://doc.shiyanlou.com/document-uid18510labid1118timestamp1500451929664.png/wm' alt='img' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n414' class='md-header-anchor '></a>java.lang 包</h2><figure><table><thead><tr><th>原始数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte（字节）</td><td>Byte</td></tr><tr><td>char（字符）</td><td>Character</td></tr><tr><td>int（整型）</td><td>Integer</td></tr><tr><td>long （长整型）</td><td>Long</td></tr><tr><td>float（浮点型）</td><td>Float</td></tr><tr><td>double （双精度）</td><td>Double</td></tr><tr><td>boolean （布尔）</td><td>Boolean</td></tr><tr><td>short（短整型）</td><td>Short</td></tr></tbody></table></figure><h3><a name='header-n443' class='md-header-anchor '></a>一、String</h3><p><strong>String 对象创建后则不能被修改</strong>，是不可变的，所谓的修改其实是创建了新的对象，所指向的内存空间不同。</p><p>&nbsp;</p><h4><a name='header-n446' class='md-header-anchor '></a>0.java中String new和直接赋值的区别</h4><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">对于字符串：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 78px;"></div><div class="CodeMirror-gutters" style="display: none; height: 78px;"></div></div></div></pre><p>例如：</p><p>String str1=&quot;ABC&quot;； 和String str2 = new String(&quot;ABC&quot;); </p><p><strong>String str1=&quot;ABC&quot; 可能创建一个对象或者不创建对象</strong>，如果&quot;ABC&quot;这个字符串在java String池里不存在，会在java String池创建这个一个String对象(&quot;ABC&quot;).如果已经存在，str1直接reference to 这个String池里的对象。</p><p><strong>String str2 = new String(&quot;ABC&quot;) 至少创建一个对象，也可能两个。</strong>因为用到new 关键字，会在heap创建一个 str2 的String 对象，它的value 是 &quot;ABC&quot;.同时，如果&quot;ABC&quot;这个字符串在java String池里不存在，会在java String池创建这个一个String对象(&quot;ABC&quot;).</p><p>String 有一个<strong>intern()</strong> 方法，native，用来检测在String pool是否已经有这个String存在。</p><p>&nbsp;</p><p>考虑下面的问题：</p><p>String str1 = new String(&quot;ABC&quot;);
String str2 = new String(&quot;ABC&quot;);</p><p>str1 == str2 的值是True 还是False呢？ False.</p><p>String str3 = &quot;ABC&quot;;
String str4 = &quot;ABC&quot;;</p><p>String str5 = &quot;A&quot; + &quot;BC&quot;;</p><p>str3 == str4 的值是True 还是False呢？ True.</p><p>str3 == str5 的值是True 还是False呢？ True.</p><p>String a = &quot;ABC&quot;;
String b=&quot;AB&quot;;
String c=b+&quot;C&quot;;
System.out.println(a==c); false
a和b都是字符串常量所以在编译期就被确定了！</p><p>而c中有个b是引用不是字符串常量所以不会在编译期确定。
而String是final的！所以在b+&quot;c&quot;的时候实际上是新创建了一个对象，然后在把新创建对象的引用传给c.</p><p>&nbsp;</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public static void main(String[] args) throws Exception { &nbsp;</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String a =  "b" ; &nbsp; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String b =  "b" ; &nbsp; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( a == b); &nbsp; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String d = new String( "d" ).intern() ; //如果吧new和intern拆分成两条语句那结果就是false，intern返回的是常量池中的引用，如果不赋值那还是引用堆中的；除非是d=new String（“d”）+new String（“d”）;此时再调用d.intern，在jdk6之前是复制d对象成副本放到常量池中，jdk6之后则直接将堆中的引用放到常量池中，此时如果有字符串“dd”，他指向的是常量池中“dd”的堆对象的引用，这时候d就和“dd”地址一样了。</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String c = "d" ; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( c == d);  //</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println("------------------"); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String d1 = new String( "d" ) ; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String e1=d1.intern();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String c1 = "d" ; &nbsp; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( c1 == d1); &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( c1 == e1); &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( e1 == d1); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println("------------------"); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String s1=new String("kvill"); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String s2=s1.intern(); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( s1==s2 ); //s1=s1.intern()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( s1+" "+s2 ); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  System.out.println( s2==s1.intern() ); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">} &nbsp;</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 676px;"></div><div class="CodeMirror-gutters" style="display: none; height: 676px;"></div></div></div></pre><p>运行结果：
true
true
false
true
false
false
kvill kvill
true</p><p>s1==s1.intern()为false说明原来的“kvill”仍然存在； </p><p>例子代码：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><span><span>​</span>x</span></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String s1 = "china"; </span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String s2 = "china";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String s3 = "china"; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String ss1 = new String("china"); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String ss2 = new String("china"); </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String ss3 = new String("china"); &nbsp; </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  这里解释一下，对于通过 new 产生一个字符串（假设为 ”china” ）时，会先去常量池中查找是否已经有了 ”china” 对象，如果没有则在常量池中创建一个此字符串对象，然后堆中再创建一个常量池中此 ”china” 对象的拷贝对象。</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 260px;"></div><div class="CodeMirror-gutters" style="display: none; height: 260px;"></div></div></div></pre><p><strong>也就是有道面试题： String s = new String(“xyz”); 产生几个对象？</strong></p><p><strong>一个或两个。如果常量池中原来没有 ”xyz”, 就是两个。如果原来的常量池中存在“xyz”时，就是一个。</strong></p><p>对于基础类型的变量和常量：变量和引用存储在栈中，常量存储在常量池中。</p><p>应用的情况：建议在平时的使用中，尽量使用String = “abcd”;这种方式来创建字符串，而不是String = new String(“abcd”);这种形式，因为使用new构造器创建字符串对象一定会开辟一个新的heap（堆）空间，而双引号则是采用了String interning(字符串驻留)进行了优化，效率比构造器高。</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n475' class='md-header-anchor '></a>1.Java 中 String 类的常用方法 Ⅰ</h4><p>String 类提供了许多用来处理字符串的方法，例如，获取字符串长度、对字符串进行截取、将字符串转换为大写或小写、字符串分割等，下面我们就来领略它的强大之处吧。</p><p>String 类的常用方法：</p><p><a href='http://img.mukewang.com/53d9f7d200010bb007780366.jpg'><img src='http://img.mukewang.com/53d9f7d200010bb007780366.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">`equalsIgnoreCase()`方法，其用法与 equals 一致，不过它会忽视大小写。</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">字符串连接有两种方法：</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">1.使用`+`，比如`String s = "Hello " + "World!"`使用`+`进行连接，不仅可以连接字符串，也可以连接其他类型。但是要求进行连接时至少有一个参与连接的内容是字符串类型。</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">2.使用 String 类的 concat() 方法</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 182px;"></div><div class="CodeMirror-gutters" style="display: none; height: 182px;"></div></div></div></pre><p>结合代码来熟悉一下方法的使用：（JAVA前后有两个空格）</p><p><a href='http://img.mukewang.com/53a8e7320001a8d807090391.jpg'><img src='http://img.mukewang.com/53a8e7320001a8d807090391.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果：</p><p><a href='http://img.mukewang.com/53a8e74e00011f5703850166.jpg'><img src='http://img.mukewang.com/53a8e74e00011f5703850166.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p><strong>友情提示：</strong></p><p>\1. 字符串 str 中字符的索引从0开始，范围为 0 到 str.length()-1</p><p>\2. 使用 indexOf 进行字符或字符串查找时，如果匹配返回位置索引；如果没有匹配结果，返回 -1</p><p>\3. 使用 substring(beginIndex , endIndex) 进行字符串截取时，包括 beginIndex 位置的字符，不包括 endIndex 位置的字符</p><p>&nbsp;</p><h4><a name='header-n489' class='md-header-anchor '></a>2.Java 中的 String 类常用方法 Ⅱ</h4><p>我们继续来看 String 类常用的方法，如下代码所示：</p><p><a href='http://img.mukewang.com/53a9260b0001808e06540410.jpg'><img src='http://img.mukewang.com/53a9260b0001808e06540410.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果：</p><p><a href='http://img.mukewang.com/53a9239300017e1c07910137.jpg'><img src='http://img.mukewang.com/53a9239300017e1c07910137.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>那么，“==” 和 equals() 有什么区别呢？
==: 判断两个字符串在内存中首地址是否相同，即判断是否是同一个字符串对象
equals(): 比较存储在两个字符串对象中的内容是否一致</p><p>PS：字节是计算机存储信息的基本单位，1 个字节等于 8 位， gbk 编码中 1 个汉字字符存储需要 2 个字节，1 个英文字符存储需要 1 个字节。所以我们看到上面的程序运行结果中，每个汉字对应两个字节值，如“学”对应 “-47 -89” ，而英文字母 “J” 对应 “74” 。同时，我们还发现汉字对应的字节值为负数，原因在于每个字节是 8 位，最大值不能超过 127，而汉字转换为字节后超过 127，如果超过就会溢出，以负数的形式显示。</p><p>&nbsp;</p><h4><a name='header-n497' class='md-header-anchor '></a>3.java中字符串和字符数组的转换？</h4><p>1、字符串是类，字符数组是数组。
2、字符数组是char类型的，字符串是String类型的
3、两者之间的相互转化：
String s=&quot;this is a string&quot;;
char[ ] c={&#39;t&#39;,&#39;h&#39;,&#39;i&#39;,&#39;s&#39;,&#39;i&#39;,&#39;s&#39;,&#39;a&#39;,&#39;c&#39;,&#39;h&#39;,&#39;a&#39;,&#39;r&#39;};
字符串转换为字符数组
char[ ] ch=s.toCharArray();
字符数组转化为字符串
String str=string.valueOf(c);  </p><p>&nbsp;</p><h4><a name='header-n500' class='md-header-anchor '></a>4.StringBuilder 和StringBuffer</h4><p>当频繁操作字符串时，就会额外产生很多临时变量。使用 StringBuilder 或 StringBuffer 就可以避免这个问题。至于 StringBuilder 和StringBuffer ，它们基本相似，不同之处，<strong>StringBuffer 是线程安全的，而 StringBuilder 则没有实现线程安全功能</strong>，所以性能略高。因此一般情况下，如果需要创建一个内容可变的字符串对象，应优先考虑使用 StringBuilder 类。</p><p>&nbsp;</p><h5><a name='header-n503' class='md-header-anchor '></a>StringBuffer</h5><figure><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>StringBuffer()</td><td>构造一个其中不带字符的字符串缓冲区，其初始容量为 16 个字符</td></tr><tr><td>StringBuffer(CharSequence seq)</td><td>构造一个字符串缓冲区，它包含与指定的 CharSequence 相同的字符</td></tr><tr><td>StringBuffer(int capacity)</td><td>构造一个不带字符，但具有指定初始容量的字符串缓冲区</td></tr><tr><td>StringBuffer(String str)</td><td>构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容</td></tr></tbody></table></figure><p>StringBuffer 类的常用方法：</p><figure><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>insert(int offsetm,Object s)</td><td>StringBuffer</td><td>在 offsetm 的位置插入字符串 s</td></tr><tr><td>append(Object s)</td><td>StringBuffer</td><td>在字符串末尾追加字符串 s</td></tr><tr><td>length()</td><td>int</td><td>确定 StringBuffer 对象的长度</td></tr><tr><td>setCharAt(int pos,char ch)</td><td>void</td><td>使用 ch 指定的新值设置 pos 指定的位置上的字符</td></tr><tr><td>toString()</td><td>String</td><td>转换为字符串形式</td></tr><tr><td>reverse()</td><td>StringBuffer</td><td>反转字符串</td></tr><tr><td>delete(int start, int end)</td><td>StringBuffer</td><td>删除调用对象中从 start 位置开始直到 end 指定的索引（end-1）位置的字符序列</td></tr><tr><td>replace(int start, int end, String s)</td><td>StringBuffer</td><td>使用一组字符替换另一组字符。将用替换字符串从 start 指定的位置开始替换，直到 end 指定的位置结束</td></tr></tbody></table></figure><p>&nbsp;</p><p>&nbsp;</p><h5><a name='header-n560' class='md-header-anchor '></a>StringBuilder </h5><p>StringBuilder 类提供了很多方法来操作字符串：</p><p><a href='http://img.mukewang.com/53a7d34300011c6005970125.jpg'><img src='http://img.mukewang.com/53a7d34300011c6005970125.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>例如：在下面的示例代码中，创建了 StringBuilder 对象，用来存储字符串，并对其做了追加和插入操作。这些操作修改了 str 对象的值，而没有创建新的对象，这就是 StringBuilder 和 String 最大的区别。</p><p><a href='http://img.mukewang.com/53a7d36c0001e3cd06760242.jpg'><img src='http://img.mukewang.com/53a7d36c0001e3cd06760242.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>运行结果： <a href='http://img.mukewang.com/53a7d3ab0001ff3803060080.jpg'><img src='http://img.mukewang.com/53a7d3ab0001ff3803060080.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n569' class='md-header-anchor '></a>Java 中基本类型和字符串之间的转换</h3><p>在程序开发中，我们经常需要在基本数据类型和字符串之间进行转换。</p><p>其中，基本类型转换为字符串有三种方法：</p><p>\1. 使用包装类的 toString() 方法</p><p>\2. 使用String类的 valueOf() 方法</p><p>\3. 用一个空字符串加上基本类型，得到的就是基本类型数据对应的字符串</p><p><a href='http://img.mukewang.com/53abea61000151e105120118.jpg'><img src='http://img.mukewang.com/53abea61000151e105120118.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>再来看，将字符串转换成基本类型有两种方法：</p><p>\1. 调用包装类的 parseXxx 静态方法</p><p>\2. 调用包装类的 valueOf() 方法转换为基本类型的包装类，会自动拆箱</p><p><a href='http://img.mukewang.com/53abeaad000109af04610098.jpg'><img src='http://img.mukewang.com/53abeaad000109af04610098.jpg' alt='img' referrerPolicy='no-referrer' /></a></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n583' class='md-header-anchor '></a>valueOf与parseInt方法</h4><p><strong>首先从返回类型可以看出parseInt返回的是基本类型int，而valueOf返回的是对象（可自动拆装箱）。</strong></p><p>源码：</p><p><code>public static Integer valueOf(String s) throws NumberFormatException {</code>
        <code>return Integer.valueOf(parseInt(s, 10));</code>
 <code>}</code></p><p> <code>public static Integer valueOf(int i) {</code>
    <code>assert IntegerCache.high &gt;= 127;</code>
 <span>	</span><code>if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</code>
        <code>return IntegerCache.cache[i + (-IntegerCache.low)];</code>
    <code>return new Integer(i);</code>
 <code>}</code></p><p> <code>public static int parseInt(String s) throws NumberFormatException {</code>
    <span>	</span><code>return parseInt(s,10);</code>
 <code>}</code></p><p>因为JDK5以后实现了自动拆装箱，因而两者的差别也不是特别大了，但是从效率上考虑，建议首先考虑parseInt方法。</p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n592' class='md-header-anchor '></a>二、包装类</h3><h4><a name='header-n593' class='md-header-anchor '></a>1.Integer 类</h4><p>java.lang 包中的 Integer 类、Long 类和 Short 类都是 Number 的子类，他们的区别在于不同子类里面封装着不同的数据类型，比如 Integer 类包装了一个基本类型 int。其包含的方法基本相同。</p><figure><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>byteValue()</td><td>byte</td><td>以 byte 类型返回该 Integer 的值</td></tr><tr><td>compareTo(Integer anotherInteger)</td><td>int</td><td>在数字上比较 Integer 对象。如果这两个值相等，则返回 0；如果调用对象的数值小于 anotherInteger 的数值，则返回负值；如果调用对象的数值大于 anotherInteger 的数值，则返回正值</td></tr><tr><td>equals(Object IntegerObj)</td><td>boolean</td><td>比较此对象与指定对象是否相等</td></tr><tr><td>intValue()</td><td>int</td><td>以 int 型返回此 Integer 对象</td></tr><tr><td>shortValue()</td><td>short</td><td>以 short 型返回此 Integer 对象</td></tr><tr><td>longValue()</td><td>long</td><td>以 long 型返回此 Integer 对象</td></tr><tr><td>floatValue()</td><td>float</td><td>以 float 型返回此 Integer 对象</td></tr><tr><td>doubleValue()</td><td>double</td><td>以 double 型返回此 Integer 对象</td></tr><tr><td>toString()</td><td>String</td><td>返回一个表示该 Integer 值的 String 对象</td></tr><tr><td>valueOf(String str)</td><td>Integer</td><td>返回保存指定的 String 值的 Integer 对象</td></tr><tr><td>parseInt(String str)</td><td>int</td><td>将字符串参数作为有符号的十进制整数进行解析</td></tr><tr><td>parseInt(String str,int radix)</td><td>int</td><td>实现将字符串按照参数 radix 指定的进制转换为十进制</td></tr></tbody></table></figure><p>&nbsp;</p><h4><a name='header-n649' class='md-header-anchor '></a>2.Character 类</h4><p>Character 类型的对象包含类型为 char 的单个字段。</p><figure><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>isDigit(char ch)</td><td>boolean</td><td>确定字符是否为数字</td></tr><tr><td>isLetter(char ch)</td><td>boolean</td><td>确定字符是否为字母</td></tr><tr><td>isLowerCase(char ch)</td><td>boolean</td><td>确定字符是否为小写字母</td></tr><tr><td>isUpperCase(char ch)</td><td>boolean</td><td>确定字符是否为大写字母</td></tr><tr><td>isWhitespace(char ch)</td><td>boolean</td><td>确定字符是否为空白字符</td></tr><tr><td>isUnicodeIdentifierStart(char ch)</td><td>boolean</td><td>确定是否允许将指定字符作为 Unicode 标识符中的首字符</td></tr></tbody></table></figure><p>&nbsp;</p><h4><a name='header-n681' class='md-header-anchor '></a>3.Boolean 类</h4><p>一个 Boolean 类型的对象只包含一个类型为 boolean 的字段。</p><p>Boolean 类的构造方法也有两个：</p><ol start='' ><li>Boolean(boolean value)，创建一个表示 value 参数的 Boolean 对象，如<code>Boolean b = new Boolean(true)</code></li><li>Boolean(String s)，如果 String 参数不为 null 且在忽略大小写时等于 &quot;true&quot;,创建一个表示 true 值的 Boolean 对象，如<code>Boolean b = new Boolean(&quot;ok&quot;)</code>，为 false。</li></ol><figure><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>booleanValue()</td><td>boolean</td><td>将 Boolean 对象的值以对应的 boolean 值返回</td></tr><tr><td>equals(Object obj)</td><td>boolean</td><td>判断调用该方法的对象与 obj 是否相等。当且仅当参数不是 null，而且与调用该方法的对象一样都表示同一个 boolean 值的 Boolean 对象时，才返回 true</td></tr><tr><td>parseBoolean(String s)</td><td>boolean</td><td>将字符串参数解析为 boolean 值</td></tr><tr><td>toString()</td><td>String</td><td>返回表示该 boolean 值的 String 对象</td></tr><tr><td>valueOf(String s)</td><td>Boolean</td><td>返回一个用指定得字符串表示值的 boolean 值</td></tr></tbody></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n716' class='md-header-anchor '></a>三、Math</h3><figure><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>sin(double numvalue)</td><td>double</td><td>计算角 numvalue 的正弦值</td></tr><tr><td>cos(double numvalue)</td><td>double</td><td>计算角 numvalue 的余弦值</td></tr><tr><td>acos(double numvalue)</td><td>double</td><td>计算 numvalue 的反余弦</td></tr><tr><td>asin(double numvalue)</td><td>double</td><td>计算 numvalue 的反正弦</td></tr><tr><td>atan(double numvalue)</td><td>double</td><td>计算 numvalue 的反正切</td></tr><tr><td>pow(double a, double b)</td><td>double</td><td>计算 a 的 b 次方</td></tr><tr><td>sqrt(double numvalue)</td><td>double</td><td>计算给定值的正平方根</td></tr><tr><td>abs(int numvalue)</td><td>int</td><td>计算 int 类型值 numvalue 的绝对值，也接收 long、float 和 double 类型的参数</td></tr><tr><td>ceil(double numvalue)</td><td>double</td><td>返回大于等于 numvalue 的最小整数值</td></tr><tr><td>floor(double numvalue)</td><td>double</td><td>返回小于等于 numvalue 的最大整数值</td></tr><tr><td>max(int a, int b)</td><td>int</td><td>返回 int 型 a 和 b 中的较大值，也接收 long、float 和 double 类型的参数</td></tr><tr><td>min(int a, int b)</td><td>int</td><td>返回 a 和 b 中的较小值，也可接受 long、float 和 double 类型的参数</td></tr><tr><td>rint(double numvalue)</td><td>double</td><td>返回最接近 numvalue 的整数值</td></tr><tr><td>round(T arg)</td><td>arg 为 double 时返回 long，为 float 时返回 int</td><td>返回最接近 arg 的整数值</td></tr><tr><td>random()</td><td>double</td><td>返回带正号的 double 值，该值大于等于 0.0 且小于 1.0</td></tr></tbody></table></figure><p>&nbsp;</p><h3><a name='header-n783' class='md-header-anchor '></a>四、类 Class</h3><p>Class 类的实例表示正在运行的 Java 应用程序中的类或接口。在 Java 中，每个 Class 都有一个相应的 Class 对象，即每一个类，在生成的<code>.class</code>文件中，就会产生一个 Class 对象，用于表示这个类的类型信息。我们获取 Class 实例有三种方法：</p><ol start='' ><li>利用<strong>对象调用 `getClass()</strong>`方法获取该对象的 Class 实例</li><li>使用 <strong>Class 类的静态方法 `forName(String className)</strong>`，用类的名字获取一个 Class 实例</li><li>运用<code>**.class</code>的方式来获取 Class 实例**，对于基本数据类型的封装类，还可以采用<code>.TYPE</code>来获取相对应的基本数据类型的 Class 实例</li></ol><p><img src='https://doc.shiyanlou.com/document-uid79144labid1085timestamp1435763025133.png/wm' alt='Class 类对象访问' referrerPolicy='no-referrer' /></p><p><img src='https://doc.shiyanlou.com/document-uid79144labid1085timestamp1435763058113.png/wm' alt='Class 类对象访问结果' referrerPolicy='no-referrer' /></p><p>class 类没有共有的构造方法，它由 JVM 自动调用。</p><h3><a name='header-n795' class='md-header-anchor '></a>五、反射</h3><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ul><li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li><strong>Constructor</strong> ：可以用 Constructor 创建新的对象。</li></ul><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public class Apple {</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  private int price;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  public int getPrice() {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  return price;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  public void setPrice(int price) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  this.price = price;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  public static void main(String[] args) throws Exception{</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  //正常的调用</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Apple apple = new Apple();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  apple.setPrice(5);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  System.out.println("Apple Price:" + apple.getPrice());</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  //使用反射调用</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Class clz = Class.forName("com.chenshuyi.api.Apple");</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Method setPriceMethod = clz.getMethod("setPrice", int.class);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Constructor appleConstructor = clz.getConstructor();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Object appleObj = appleConstructor.newInstance();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  setPriceMethod.invoke(appleObj, 14);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  Method getPriceMethod = clz.getMethod("getPrice");</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp;  System.out.println("Apple Price:" + getPriceMethod.invoke(appleObj));</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">结果：</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Apple Price:5</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">Apple Price:14</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 832px;"></div><div class="CodeMirror-gutters" style="display: none; height: 832px;"></div></div></div></pre><p><strong>反射的优点：</strong></p><ul><li><strong>可扩展性</strong> ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li><li><strong>类浏览器和可视化开发环境</strong> ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li><li><strong>调试器和测试工具</strong> ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li></ul><p><strong>反射的缺点：</strong></p><p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p><ul><li><strong>性能开销</strong> ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</li><li><strong>安全限制</strong> ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</li><li><strong>内部暴露</strong> ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</li></ul><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n825' class='md-header-anchor '></a>六、注解Annotation</h3><p><a href='https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html' target='_blank' class='url'>https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html</a></p><p>注解其实就是<strong>代码中的特殊标记</strong>，这些标记可以<strong>在编译、类加载、运行时被读取，并执行相对应的处理</strong>。</p><p>Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 <strong>java.lang.annotation</strong> 包中。</p><p>&nbsp;</p><p><strong>带成员变量的注解：</strong></p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public @interface MyAnnotation {//interface加一个@</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  //定义了两个成员变量</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  String username() default "";</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  int age();</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 156px;"></div><div class="CodeMirror-gutters" style="display: none; height: 156px;"></div></div></div></pre><p>注意：在注解上<strong>定义的成员变量只能是String、数组、Class、枚举类、注解</strong></p><h5><a name='header-n833' class='md-header-anchor '></a>注解的用处：</h5><p>      1、生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param @return 等
​      2、跟踪代码依赖性，实现替代配置文件功能。比如Dagger 2 依赖注入
​      3、在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。</p><h5><a name='header-n835' class='md-header-anchor '></a>注解的原理：</h5><p>　　注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。</p><h5><a name='header-n837' class='md-header-anchor '></a>元注解：</h5><p><strong><a href='https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html' target='_blank' class='url'>https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html</a></strong></p><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：
   @Documented – 注解是否将包含在JavaDoc中
   @Retention – 什么时候使用该注解
   @Target – 注解用于什么地方
   @Inherited – 是否允许子类继承该注解</p><h5><a name='header-n840' class='md-header-anchor '></a>常见标准的Annotation：</h5><p>  1.）Override
      java.lang.Override 是一个标记类型注解，它被用作标注方法。它<strong>说明了被标注的方法重载了父类的方法</strong>，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java 编译器将以一个编译错误来警示。
  2.）Deprecated
     Deprecated 也是一种标记类型注解。<strong>当一个类型或者类型成员使用@Deprecated 修饰的话，编译器将不鼓励使用这个被标注的程序元素。</strong>所以使用这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为@Deprecated，但编译器仍然要报警。
 3.）SuppressWarnings
     SuppressWarning 不是一个标记类型注解。它有一个类型为String[] 的成员，这个成员的值为被禁止的警告名。对于javac 编译器来讲，被-Xlint 选项有效的警告名也同样对<strong>@SuppressWarings 有效，同时编译器忽略掉无法识别的警告名。</strong>
　　@SuppressWarnings(&quot;unchecked&quot;)</p><p>&nbsp;</p><h3><a name='header-n843' class='md-header-anchor '></a>七、Object类</h3><figure><table><thead><tr><th>方法</th><th>返回值</th><th>功能描述</th></tr></thead><tbody><tr><td>equals(Objectobj)</td><td>boolean</td><td>将当前对象实例与给定的对象进行比较，检查它们是否相等</td></tr><tr><td>finalize() throws Throwable</td><td>void</td><td>当垃圾回收器确定不存在对象的更多引用时，由对象的垃圾回收器调用此方法。通常被子类重写</td></tr><tr><td>getClass()</td><td>Class</td><td>返回当前对象的 Class 对象</td></tr><tr><td>toString()</td><td>String</td><td>返回此对象的字符串表示</td></tr><tr><td>wait() throws InterruptedException</td><td>void</td><td>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，使当前线程进入等待状态</td></tr></tbody></table></figure><h4><a name='header-n869' class='md-header-anchor '></a>toString()方法</h4><p>在Object类里面定义toString()方法的时候返回的对象在哈希code码(对象地址字符串)</p><p>可以通过重写toString()方法表示出对象的属性</p><h4><a name='header-n872' class='md-header-anchor '></a>equals和==的区别</h4><p>==是一个比较运算符，基本数据类型比较的是值，引用数据类型比较的是地址值。</p><p>equals()是一个方法，只能比较引用数据类型。重写前比较的是地址值，重写后比一般是比较对象的属性。</p><p><strong>除了String和封装器，equals()和“==”没什么区别</strong>
<strong>但String和封装器重写了equals()，所以在这里面，equals()指比较字符串或封装对象对应的原始值是否相等，&quot;==&quot;是比较两个对象是否为同一个对象</strong></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n879' class='md-header-anchor '></a>java日期和随机数</h2><p>学习 java.util 中的 Date 类、Calendar 类，Random 类以及 java.time 包中的 LocalTime 类。</p><h3><a name='header-n881' class='md-header-anchor '></a>一、java.util 和 java.time 包介绍</h3><p>java.util 包提供了一些实用的方法和数据结构。比如日期类 Date，日历类 Calendar 以及随机数类 Random，同时包里还提供了 collection 框架，像堆栈 Stack、向量 Vector、位集合 Bitset 以及哈希表 Hashtable 等表示数据结构的类。而 java.time 包是 java8 新提供的包，里面对时间和日期提供了新的 api，弥补了 java.util 包对日期和时间操作的不足。</p><p><img src='https://doc.shiyanlou.com/document-uid79144labid1089timestamp1435767072006.png/wm' alt='java.util层次' referrerPolicy='no-referrer' /></p><p>本次课程主要介绍 Date 类、Calendar 类、Random 类以及 LocalTime 类的相关知识，其他 collection 框架等方面的内容将在后面的课程进行介绍。</p><p>&nbsp;</p><h3><a name='header-n886' class='md-header-anchor '></a>二、Date 类和Calendar 类</h3><p>链接：<a href='https://www.shiyanlou.com/courses/109/labs/1119/document/#2.4%20java.time%20' target='_blank' class='url'>https://www.shiyanlou.com/courses/109/labs/1119/document/#2.4%20java.time%20</a>包</p><p>Date 类表示日期和时间，里面封装了操作日期和时间的方法。Date 类经常用来获取系统当前时间。</p><p>我们来看看类 Date 中定义的未过时的构造方法：</p><figure><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>Date()</td><td>构造一个 Date 对象并对其进行初始化以反映当前时间</td></tr><tr><td>Date(long date)</td><td>构造一个 Date 对象，并根据相对于 GMT 1970 年 1 月 1 日 00:00:00 的毫秒数对其进行初始化</td></tr></tbody></table></figure><p>### </p><p>在早期的 JDK 版本中，Date 类附有两大功能： 　　</p><ol start='' ><li>允许用年、月、日、时、分、秒来解释日期</li><li>允许对表示日期的字符串进行格式化和句法分析</li></ol><p>在 JDK1.1 中提供了类 Calendar 来完成第一种功能，类 DateFormat 来完成第二项功能。DateFormat 是 java.text 包中的一个类。与 Date 类有所不同的是，DateFormat 类可以接受用各种语言和不同习惯表示的日期字符串。</p><p>但是 Calendar 类是一个抽象类，它完成 Date 类与普通日期表示法之间的转换，而我们更多的是使用 Calendar 类的子类 GregorianCalendar 类。它实现了世界上普遍使用的公历系统。当然我们也可以继承 Calendar 类，然后自己定义实现日历方法。</p><p>&nbsp;</p><h3><a name='header-n910' class='md-header-anchor '></a>三、java.time 包</h3><p>因为 java8 之前的日期和时间 api 饱受诟病，比如线程安全问题，比如 Date 的月份是从 0 开始的！而 java.time 包中将月份封装成为了枚举类型。</p><p>首先了解一下 LocalTime 类，LocalTime 类是一个不可变类（也就是用 final 修饰的类），和 String 类一样，所以它是线程安全的。除了 LocalTime 还有 LocalDate（日期）、LocalDateTime（日期和时间）等，他们的使用方式都差不多。</p><p>初始化例子：LocalDateTime currentTime = LocalDateTime.now();</p><p><strong>Java8的DateTimeFormatter是线程安全的，而SimpleDateFormat并不是线程安全。</strong></p><p><strong>DateTimeFormatter可以用来格式化输出日期时间</strong></p><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n918' class='md-header-anchor '></a>四、Random 类</h3><p>Java 实用工具类库中的类 java.util.Random 提供了产生各种类型随机数的方法。它可以产生 int、long、float、double 以及 Gaussian 等类型的随机数。这也是它与 java.lang.Math 中的方法 Random() 最大的不同之处，后者只产生 double 型的随机数。</p><figure><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>Random()</td><td>产生一个随机数需要基值，这里将系统时间作为 seed</td></tr><tr><td>Random(long seed)</td><td>使用单个 long 种子创建一个新的随机数生成器</td></tr></tbody></table></figure><p><strong>强调：种子数只是随机算法的起源数字，和生成的随机数字的区间无关。相同种子数的Random对象，相同次数生成的随机数字是完全相同的。</strong></p><p>普通方法原型：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 4px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//该方法是设定基值seed</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public synchronized void setSeed(long seed)</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//该方法是产生一个整型随机数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public int nextInt()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//该方法是产生一个long型随机数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public long nextLong()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//该方法是产生一个Float型随机数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public float nextFloat()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//该方法是产生一个Double型随机数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public double nextDouble()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">//该方法是产生一个double型的Gaussian随机数</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">public synchronized double nextGaussian()</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span cm-text="">​</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">/*</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">synchronized  是 Java 语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">*/</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 572px;"></div><div class="CodeMirror-gutters" style="display: none; height: 572px;"></div></div></div></pre><p>例子：</p><p>1、生成[0,10]区间的整数</p><p>int n3 = r.nextInt(11);</p><p>相对于整数区间，[0,10]区间和[0,11)区间等价，所以即生成[0,11)区间的整数。</p><p>2、生成[-3,15)区间的整数</p><p>int n4 = r.nextInt(18) - 3;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n942' class='md-header-anchor '></a>Java 集合框架</h2><p>&nbsp;</p><h3><a name='header-n944' class='md-header-anchor '></a>一、Collection 接口</h3><p><img src='https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/73403d84-d921-49f1-93a9-d8fe050f3497.png' alt='img' referrerPolicy='no-referrer' /></p><p>它也是 List、Set 和 Queue 接口的父接口。Collection 接口中定义了可用于操作 List、Set 和 Queue 的方法——增删改查。</p><figure><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>add(E e)</td><td>boolean</td><td>向 collection 的尾部追加指定的元素（可选操作）</td></tr><tr><td>addAll(Collection&lt;? extend E&gt; c)</td><td>boolean</td><td>将指定 collection 中的所有元素都添加到此 collection 中（可选操作）</td></tr><tr><td>clear()</td><td>void</td><td>移除此 collection 中的所有元素（可选操作）</td></tr><tr><td>contains(Object o)</td><td>boolean</td><td>如果此 collection 包含指定的元素，则返回 true</td></tr><tr><td>containsAll(Collection&lt;?&gt; c)</td><td>boolean</td><td>如果此 collection 包含指定 collection 的所有元素，则返回 true</td></tr><tr><td>equals(Object o)</td><td>boolean</td><td>比较此 collection 与指定对象是否相等</td></tr><tr><td>hashCode()</td><td>int</td><td>返回此 collection 的哈希码值</td></tr><tr><td>isEmpty()</td><td>boolean</td><td>如果此 collection 不包含元素，则返回 true</td></tr><tr><td>iterator()</td><td>Iterator<E></td><td>返回在此 collection 的元素上进行迭代的迭代器</td></tr><tr><td>remove(Object o)</td><td>boolean</td><td>移除此 collection 中出现的首个指定元素(可选操作)</td></tr><tr><td>removeAll(Collection&lt;?&gt; c)</td><td>boolean</td><td>移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）</td></tr><tr><td>retainAll(Collection&lt;?&gt; c)</td><td>boolean</td><td>仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）</td></tr><tr><td>size()</td><td>int</td><td>返回此 collection 中的元素数</td></tr><tr><td>toArray()</td><td>Object[]</td><td>返回包含此 collection 中所有元素的数组</td></tr><tr><td>toArray(T[] a)</td><td><T> T[]</td><td>返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同</td></tr></tbody></table></figure><h3><a name='header-n1012' class='md-header-anchor '></a>二、Map接口</h3><p><img src='https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/774d756b-902a-41a3-a3fd-81ca3ef688dc.png' alt='img' referrerPolicy='no-referrer' /></p><blockquote><p><strong>TreeMap：</strong>基于红黑树实现。
<strong>HashMap：</strong>基于哈希表实现。
<strong>HashTable：</strong>和 HashMap 类似，但它是<strong>线程安全的</strong>，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 <strong>ConcurrentHashMap</strong> 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。
<strong>LinkedHashMap：</strong>使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p></blockquote><p>Map 接口也是一个非常重要的集合接口，用于存储键/值对。Map 中的元素都是成对出现的，键值对就像数组的索引与数组的内容的关系一样，将一个键映射到一个值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。我们可以通过键去找到相应的值。</p><p>value 可以存储任意类型的对象，我们可以根据 key 键快速查找 value。Map 中的键/值对以 Entry 类型的对象实例形式存在。</p><figure><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>clear()</td><td>void</td><td>从此映射中移除所用映射关系（可选操作）</td></tr><tr><td>containsKey(Object key)</td><td>boolean</td><td>如果此映射包含指定键的映射关系，则返回 true</td></tr><tr><td>containsValue(Object value)</td><td>boolean</td><td>如果此映射将一个或多个键映射到指定值，则返回 true</td></tr><tr><td>entrySet()</td><td>Set&lt;Map.Entry&lt;K,V&gt;&gt;</td><td>返回此映射中包含的映射关系的 Set 视图</td></tr><tr><td>equals(Object o)</td><td>boolean</td><td>比较指定的对象与此映射是否相等</td></tr><tr><td>get(Object key)</td><td>V</td><td>返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null</td></tr><tr><td>hashCode()</td><td>int</td><td>返回此映射的哈希码值</td></tr><tr><td>isEmpty()</td><td>boolean</td><td>如果此映射未包含键-值映射关系，则返回 true</td></tr><tr><td>keySet()</td><td>Set<K></td><td>返回此映射中包含的键的 Set 视图</td></tr><tr><td>put(K key, V value)</td><td>V</td><td>将指定的值与此映射中的指定键关联（可选操作）</td></tr><tr><td>putAll(Map&lt;? extends K, ? extends V&gt; m)</td><td>void</td><td>从指定映射中将所有映射关系复制到此映射中（可选操作）</td></tr><tr><td>remove(Object key)</td><td>V</td><td>如果存在一个键的映射关系，则将其从此映射中移除（可选操作）</td></tr><tr><td>size</td><td>int</td><td>返回此映射中的键-值映射关系数</td></tr><tr><td>values()</td><td>Collection<V></td><td>返回此映射中包含的值的 Collection 视图</td></tr></tbody></table></figure><p>&nbsp;</p><h3><a name='header-n1080' class='md-header-anchor '></a>三、List 接口与 ArrayList 类</h3><p>List 是一个接口，不能实例化，需要一个具体类来实现实例化。List 集合中的对象按照一定的顺序排放，里面的内容可以重复。 List 接口实现的类有：ArrayList（实现动态数组），Vector（实现动态数组），LinkedList（实现链表），Stack（实现堆栈）。</p><blockquote><p><strong>List</strong>
<strong>ArrayList：基于动态数组实现，支持随机访问。</strong>
<strong>Vector：和 ArrayList 类似，但它是线程安全的。</strong>
<strong>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，</strong>
<strong>LinkedList 还可以用作栈、队列和双向队列*</strong>*</p></blockquote><p>List 在 Collection 基础上增加的方法：</p><figure><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>add(int index, E element)</td><td>void</td><td>在列表的指定位置插入指定元素（可选操作）</td></tr><tr><td>addAll(int index, Collection&lt;? extends E&gt; c)</td><td>boolean</td><td>将指定 collection 中的所有元素都插入到列表中的指定位置（可选操作）</td></tr><tr><td>get(int index)</td><td>E</td><td>返回列表中指定位置的元素</td></tr><tr><td>indexOf(Object o)</td><td>int</td><td>返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1</td></tr><tr><td>lastIndexOf(Object o)</td><td>int</td><td>返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1</td></tr><tr><td>listIterator()</td><td>ListIterator<E></td><td>返回此列表元素的列表迭代器（按适当顺序）</td></tr><tr><td>listIterator(int index)</td><td>ListIterator<E></td><td>返回此列表元素的列表迭代器（按适当顺序），从列表的指定位置开始</td></tr><tr><td>remove(int index)</td><td>E</td><td>移除列表中指定位置的元素（可选操作）</td></tr><tr><td>set(int index, E element)</td><td>E</td><td>用指定元素替换列表中指定位置的元素（可选操作）</td></tr><tr><td>subList(int fromIndex, int toIndex)</td><td>List<E></td><td>返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的部分视图</td></tr></tbody></table></figure><p>定义时可以通过List<T>来规定集合元素的类型</p><p>ArrayList　类实现一个<strong>可增长的动态数组</strong>，它<strong>可以存储不同类型的对象，而数组则只能存放特定数据类型的值。</strong></p><p>Arrays 类， Arrays 包含用来操作数组（比如排序和搜索）的各种方法，asList() 方法用来返回一个受指定数组支持的固定大小的列表。</p><p>List 有两种基本的类型，除了 ArrayList 外，还有 LinkedList，LinkedList 类用于创建链表数据结构，两者的对比如下：</p><ul><li><strong>ArrayList：它擅长于随机访问元素，但是插入和移除元素时较慢。</strong></li><li><strong>LinkedList（链表）：它通过代价较低的在 List 中进行插入和删除操作，提供了优化的顺序访问，它在随机访问方面相对较慢，但是它的特性集较 ArrayList 更大。</strong></li></ul><p>&nbsp;</p><h3><a name='header-n1140' class='md-header-anchor '></a>四、Set 接口和 HashSet 类</h3><p>Set 接口也是 Collection 接口的子接口，它有一个很重要也是很常用的实现类——HashSet，Set 是元素无序并且不包含重复元素的 collection（List 可以重复），被称为集。</p><blockquote><p><strong>Set</strong>
<strong>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如</strong>
<strong>HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</strong>
<strong>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说</strong>
<strong>使用 Iterator 遍历 HashSet 得到的结果是不确定的。</strong>
<strong>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</strong></p></blockquote><p>HashSet 由哈希表（实际上是一个 HashMap 实例）支持。它不保证 set 的迭代顺序；特别是<strong>它不保证该顺序恒久不变</strong>。</p><p><strong>Set与List的不同，由于无序，所以不提供set()方法get()方法等</strong></p><p><strong>Set里遍历元素只能用foreach 和 iterator</strong> </p><h3><a name='header-n1147' class='md-header-anchor '></a>五、Quere接口</h3><blockquote><p><strong>Queue</strong>
<strong>LinkedList：可以用它来实现双向队列。</strong>
<strong>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</strong></p></blockquote><h3><a name='header-n1150' class='md-header-anchor '></a>五、HashSet和HashMap的区别</h3><figure><table><thead><tr><th><em>HashMap</em></th><th><em>HashSet</em></th></tr></thead><tbody><tr><td>HashMap实现了Map接口</td><td>HashSet实现了Set接口</td></tr><tr><td>HashMap储存键值对</td><td>HashSet仅仅存储对象</td></tr><tr><td>使用<strong>put()</strong>方法将元素放入map中</td><td>使用<strong>add()</strong>方法将元素放入set中</td></tr><tr><td>HashMap中使用键对象来计算hashcode值</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td></tr><tr><td>HashMap比较快，因为是使用唯一的键来获取对象</td><td>HashSet较HashMap来说比较慢</td></tr></tbody></table></figure><p>HashSet底层通过包装HashMap来实现<strong>（适配器模式）</strong>，HashSet在添加一个值的时候，实际上是将此值作为HashMap中的key来进行保存。</p><p>&nbsp;</p><h3><a name='header-n1172' class='md-header-anchor '></a>六、HashMap 类</h3><p>HashMap 是基于哈希表的 Map 接口的一个重要实现类。HashMap 中的 Entry （键值对）对象是无序排列的，Key 值和 value 值都可以为 null，但是一个 HashMap 只能有一个 key 值为 null 的映射。</p><p><strong>1、key 值不可重复，value可以
2、每个键最多只能映射到一个值</strong>
<strong>3、支持泛型，如Map&lt;K,V&gt;</strong>
<strong>4、提供了返回key集合【keySet()】，value集合【values()】以及Entry(键值对)【entrySet()】集合的方法</strong></p><ul><li><strong>底层数组+链表实现</strong>，可<strong>以存储null键和null值</strong>，线程<strong>不安全</strong></li><li>初始size为<strong>16</strong>，扩容：newsize = oldsize*2，size一定为2的n次幂</li><li>扩容针对整个Map，<strong>每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入</strong></li><li>插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）</li><li>当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀</li><li>计算index方法：index = hash &amp; (tab.length – 1)</li></ul><p><strong>HashMap：基于哈希表实现</strong>。使用HashMap要求添加的键类明确定义了hashCode()和equals()[可以重写hashCode()和equals()]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子。</p><p><strong>HashMap的初始值还要考虑加载因子:</strong></p><ul><li><strong>哈希冲突</strong>：若干Key的哈希值按数组大小取模后，如果落在同一个数组下标上，将组成一条<strong>Entry链</strong>，对Key的查找需要遍历Entry链上的每个元素执行equals()比较。</li><li><strong>加载因子</strong>：为了降低哈希冲突的概率，默认当HashMap中的键值对达到数组大小的75%时，即会触发扩容。因此，如果预估容量是100，即需要设定100/0.75＝134的数组大小。</li><li><strong>*空间换时间</strong>：如果希望加快Key查找的时间，还可以进一步降低加载因子，加大初始大小，以降低哈希冲突的概率。*</li></ul><p><strong>TreeMap：</strong>基于红黑树实现。所有的元素都保持着某种固定的顺序。TreeMap没有调优选项，因为该树总处于平衡状态。</p><h3><a name='header-n1198' class='md-header-anchor '></a>七、HashTable</h3><p>Hashtable和HashMap都实现了Map接口，但是Hashtable的实现是基于Dictionary抽象类的<strong>。Java5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</strong></p><ul><li>底层数组+链表实现，无论key还是value都<strong>不能为null</strong>，线程<strong>安全</strong>，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化</li><li>初始size为<strong>11</strong>，扩容：newsize = olesize*2+1</li><li>计算index的方法：index = (hash &amp; 0x7FFFFFFF) % tab.length</li></ul><h3><a name='header-n1207' class='md-header-anchor '></a>八、ConcurrentHashMap的实现——JDK7版本</h3><p><a href='https://www.liangzl.com/get-article-detail-28344.html' target='_blank' class='url'>https://www.liangzl.com/get-article-detail-28344.html</a></p><p><a href='https://blog.csdn.net/bill_xiang_/article/details/81122044' target='_blank' class='url'>https://blog.csdn.net/bill_xiang_/article/details/81122044</a></p><p>1.1 分段锁机制</p><p><strong>ConcurrentHashMap</strong>采用了<strong>分段锁</strong>的设计，只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争。相比于对整个Map加锁的设计，分段锁大大的提高了高并发环境下的处理能力。但同时，由于不是对整个Map加锁，导致一些需要扫描整个Map的方法（如size(), containsValue()）需要使用特殊的实现，另外一些方法（如clear()）甚至放弃了对一致性的要求（ConcurrentHashMap是弱一致性的，具体请查看<a href='http://my.oschina.net/hosee/blog/675423'>ConcurrentHashMap能完全替代HashTable吗？</a>）。</p><p><strong>Hashtable</strong>之所以效率低下主要是因为其实现使用了synchronized关键字对put等操作进行加锁，而synchronized关键字加锁是对整个对象进行加锁，也就是说在进行put等修改Hash表的操作时，锁住了整个Hash表，从而使得其表现的效率低下；因此，在JDK1.5~1.7版本，Java使用了分段锁机制实现ConcurrentHashMap.</p><p>ConcurrentHashMap中的分段锁称为<strong>Segment，它即类似于HashMap（<a href='http://my.oschina.net/hosee/blog/618953'>JDK7与JDK8中HashMap的实现</a>）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock）</strong>。ConcurrentHashMap中的HashEntry相对于HashMap中的Entry有一定的差异性：<strong>HashEntry中的value以及next都被volatile修饰</strong>，这样在多线程读写过程中能够保持它们的可见性，代码如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1214" mdtype="fences">static final class HashEntry&lt;K,V&gt; {
        final int hash;
        final K key;
        volatile V value;
        volatile HashEntry&lt;K,V&gt; next;
</pre><p><strong>并发度（Concurrency Level）</strong></p><p>并发度可以理解为程序运行时能够同时更新ConccurentHashMap且不产生锁竞争的最大线程数，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度。ConcurrentHashMap默认的并发度为16，但用户也可以在构造函数中设置并发度。。</p><p>如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。（文档的说法是根据你并发的线程数量决定，太多会导性能降低）</p><h3><a name='header-n1218' class='md-header-anchor '></a>九、JDK8中的ConcurrentHashMap</h3><p><a href='https://www.liangzl.com/get-article-detail-28344.html' target='_blank' class='url'>https://www.liangzl.com/get-article-detail-28344.html</a></p><p>ConcurrentHashMap在JDK8中进行了巨大改动，很需要通过源码来再次学习下Doug Lea的实现方法。</p><p>它摒弃了Segment（锁段）的概念，而是启用了一种全新的方式实现,利用CAS算法。它沿用了与它同时期的HashMap版本的思想，底层依然由“数组”+链表+红黑树的方式思想(<a href='http://my.oschina.net/hosee/blog/618953'>JDK7与JDK8中HashMap的实现</a>)，但是<strong>为了做到并发，又增加了很多辅助的类，例如TreeBin，Traverser等对象内部类。</strong></p><h3><a name='header-n1222' class='md-header-anchor '></a>十、ConcurrentHashMap总结</h3><p>JDK6,7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度，把HashMap分割成若干个Segment，在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。如果有，则需要依次锁住所有的Segment来计算。</p><p>jdk7中ConcurrentHashmap中，当长度过长碰撞会很频繁，链表的增改删查操作都会消耗很长的时间，影响性能,所以jdk8 中完全重写了concurrentHashmap,代码量从原来的1000多行变成了 6000多 行，实现上也和原来的分段式存储有很大的区别。</p><p>主要设计上的变化有以下几点: </p><ol start='' ><li>不采用segment而采用node，锁住node来实现减小锁粒度。</li><li>设计了MOVED状态 当resize的中过程中 线程2还在put数据，线程2会帮助resize。</li><li>使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。</li><li>sizeCtl的不同值来代表不同含义，起到了控制的作用。</li></ol><p>至于为什么JDK8中使用synchronized而不是ReentrantLock，我猜是因为JDK8中对synchronized有了足够的优化吧。</p><h3><a name='header-n1236' class='md-header-anchor '></a>十一、结合Util工具包</h3><p>数组操控工具：<strong>Arrays工具累，Collections工具类</strong></p><p>Collections工具类比较的内容必须继承Comparable接口</p><p>Comparable接口-可比较的:默认比较规则
实现该接口表示：这个类的实例可以比较大小，可以进行自然排序
定义了默认的比较规则
Comparable接口的实现类必须实现compateTo()方法
compareTo()方法返回正数表示大，负数表示小，0表示相等</p><p>Comparator接口-比较工具接口：<strong>临时</strong>比较规则
用于定义临时比较规则，而不是默认比较规则。
Comparator的实现类必须实现compare()方法
Comparable和Comparator都是java集合框架的成员</p><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n1243' class='md-header-anchor '></a>Java io</h2><p><a href='https://www.shiyanlou.com/courses/109/labs/1121/document/' target='_blank' class='url'>https://www.shiyanlou.com/courses/109/labs/1121/document/</a></p><p>大部分程序都需要进行输入/输出处理，比如从键盘读取数据、从屏幕中输出数据、从文件中写数据等等。在 Java 中，把这些不同类型的输入、输出源抽象为流（Stream），而其中输入或输出的数据则称为数据流（Data Stream），用统一的接口表示，从而使程序设计简单明了。</p><p><img src='https://doc.shiyanlou.com/document-uid79144labid1113timestamp1436110914669.png/wm' alt='流' referrerPolicy='no-referrer' /></p><p>流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p><p>流一般分为输入流（Input Stream）和输出流（Output Stream）两类，但这种划分并不是绝对的。比如一个文件，当向其中写数据时，它就是一个输出流；当从其中读取数据时，它就是一个输入流。当然，键盘只是一个输入流，而屏幕则只是一个输出流。（其实我们可以通过一个非常简单的方法来判断，只要是<strong>向内存中写入就是输入流，从内存中写出就是输出流</strong>）</p><p><img src='https://doc.shiyanlou.com/document-uid79144labid1113timestamp1436110985475.png/wm' alt='I/O 概述' referrerPolicy='no-referrer' /></p><h3><a name='header-n1250' class='md-header-anchor '></a>一、字节流</h3><h4><a name='header-n1251' class='md-header-anchor '></a>1、基类：InputStream 和 OutputStream</h4><p>字节流主要操作 byte 类型数据，以 byte 数组为准，java 中每一种字节流的基本功能依赖于基本类 InputStream 和 Outputstream，<strong>他们是抽象类，不能直接使用。<code>字节流能处理所有类型的数据（如图片、avi等）</code>。</strong></p><p>&nbsp;</p><p>InputStream 是所有表示字节输入流类的基类，继承它的子类要重新定义其中所定义的抽象方法。InputStream 是从装置来源地读取数据的抽象表示，例如 System 中的标准输入流 in 对象就是一个 InputStream 类型的实例。</p><p>InputStream 类中，方法 read() 提供了三种从流中读数据的方法：</p><ol start='' ><li>int read()：从输入流中读一个字节，形成一个 0~255 之间的整数返回（是一个抽象方法）</li><li>int read(byte b[])：从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</li><li>int read(byte b[],int off,int len)：从输入流中读取长度为 len 的数据，写入数组 b 中从索引 off 开始的位置，并返回读取得字节数。</li></ol><p>对于这三个方法，<strong>若返回-1，表明流结束，否则，返回实际读取的字符数。</strong></p><p>&nbsp;</p><p>OutputStream 是所有表示字节输出流类的基类。子类要重新定义其中所定义的抽象方法，OutputStream 是用于将数据写入目的地的抽象表示。例如 System 中的标准输出流对象 out 其类型是 java.io.PrintStream，这个类是 OutputStream 的子类。</p><figure><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>write(int b)throws IOException</td><td>将指定的字节写入此输出流（抽象方法），<strong>只写出一个byte到流，写的是b的低八位</strong></td></tr><tr><td>write(byte b[])throws IOException</td><td>将字节数组中的数据输出到流中</td></tr><tr><td>write(byte b[], int off, int len)throws IOException</td><td>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流</td></tr><tr><td>flush()throws IOException</td><td>刷新此输出流并强制写出所有缓冲的输出字节</td></tr><tr><td>close()throws IOException</td><td>关闭流</td></tr></tbody></table></figure><p>例子：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1286" mdtype="fences" style="break-inside: unset;">import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class test {
/**
 * 把输入流中的所有内容赋值到输出流中
 * @param in
 * @param out
 * @throws IOException
 */
public void copy(InputStream in, OutputStream out) throws IOException {
    byte[] buf = new  byte[4096];
    int len = in.read(buf);
    //read 是一个字节一个字节地读，字节流的结尾标志是-1
    while (len != -1){
        out.write(buf, 0, len);
        len = in.read(buf);
    }
}
public static void main(String[] args) throws IOException {
    // TODO Auto-generated method stub
    test t = new test();
    System.out.println("输入字符：");
    t.copy(System.in, System.out);
}
}
用例：
输入字符：ABC
输出：ABC
</pre><h4><a name='header-n1287' class='md-header-anchor '></a>2、文件流</h4><p>在 I/O 处理中，最常见的就是对文件的操作。java.io 包中所提供的文件操作类包括：</p><ol start='' ><li>用于读写本地文件系统中的文件：FileInputStream 和 FileOutputStream</li><li>描述本地文件系统中的文件或目录：File、FileDescriptor 和 FilenameFilter</li><li>提供对本地文件系统中文件的随机访问支持：RandomAccessFile</li></ol><p>今天我们来学习文件流的 FileInputStream 和 FileOutputStream 。</p><p>FileInputStream 类用于打开一个输入文件，若要打开的文件不存在，则会产生异常 FileNotFoundException，这是一个非运行时异常，必须捕获或声明抛弃；</p><p>FileOutputStream 类用来打开一个输出文件，若要打开的文件不存在，则会创建一个新的文件，否则原文件的内容会被新写入的内容所覆盖；</p><p><strong>在进行文件的读/写操作时，会产生非运行时异常 IOException，必须捕获或声明抛弃（</strong>其他的输入/输出流处理时也同样需要进行输入/输出异常处理）。</p><p>文件流的构造方法：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1301" mdtype="fences" style="break-inside: unset;">//打开一个以 f 描述的文件作为输入
FileInputStream(File f)

//打开一个文件路径名为 name 的文件作为输入
FileInputStream(String name)

//创建一个以 f 描述的文件作为输出
//如果文件存在，则其内容被清空
FileOutputStream(File f)

//创建一个文件路径名为 name 的文件作为输出
//文件如果已经存在，则其内容被清空
FileOutputStream(String name)

//创建一个文件路径名为 name 的文件作为输出
//文件如果已经存在，则在该输出上输出的内容被接到原有内容之后
FileOutputStream(String name, boolean append)
</pre><h4><a name='header-n1302' class='md-header-anchor '></a>3、缓冲流（速度快）</h4><p>类 BufferedInputStream 和 BufferedOutputStream 实现了带缓冲的过滤流，它提供了缓冲机制，把任意的 I/O 流“捆绑”到缓冲流上，可以提高 I/O 流的读取效率。</p><p>在初始化时，除了要指定所连接的 I/O 流之外，还可以指定缓冲区的大小。缺省时是用 32 字节大小的缓冲区；最优的缓冲区大小常依赖于主机操作系统、可使用的内存空间以及机器的配置等；一般缓冲区的大小为内存页或磁盘块等的整数倍。</p><p>BufferedInputStream 的数据成员 buf 是一个位数组，默认为 2048 字节。当读取数据来源时例如文件，BufferedInputStream 会尽量将 buf 填满。当使用 read ()方法时，实际上是先读取 buf 中的数据，而不是直接对数据来源作读取。当 buf 中的数据不足时，BufferedInputStream 才会再实现给定的 InputStream 对象的 read() 方法，从指定的装置中提取数据。</p><p>BufferedOutputStream 的数据成员 buf 是一个位数组，默认为 512 字节。当使用 write() 方法写入数据时，实际上会先将数据写至 buf 中，当 buf 已满时才会实现给定的 OutputStream 对象的 write() 方法，将 buf 数据写至目的地，而不是每次都对目的地作写入的动作。 </p><p>构造方法：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1308" mdtype="fences">//[ ]里的内容代表选填
BufferedInputStream(InputStream in [, int size])
BufferedOutputStream(OutputStream out [, int size])
</pre><p><strong>一般可以与其他字节流结合起来使用</strong>，例如：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1310" mdtype="fences">FileInputStream in = new FileInputStream("file.txt");
FileOutputStream out = new FileOutputStream("file2.txt");
//设置输入缓冲区大小为256字节
BufferedInputStream bin = new BufferedInputStream(in,256)
BufferedOutputStream bout = new BufferedOutputStream(out,256)
int len;
byte bArray[] = new byte[256];
len = bin.read(bArray); //len 中得到的是实际读取的长度，bArray 中得到的是数据
</pre><p><strong>对于 BufferedOutputStream，只有缓冲区满时，才会将数据真正送到输出流，但可以使用 flush() 方法人为地将尚未填满的缓冲区中的数据送出。</strong></p><h4><a name='header-n1312' class='md-header-anchor '></a>4、 数据流</h4><p>接口 DataInput 和 DataOutput，设计了一种较为高级的数据输入输出方式：除了可处理字节和字节数组外，还可以处理 int、float、boolean 等基本数据类型，这些数据在文件中的表示方式和它们在内存中的一样，无须转换，如 read(), readInt(), readByte()...; write(), writeChar(), writeBoolean()...此外，还可以用 readLine()方法读取一行信息。</p><ol start='' ><li><strong>分别实现了 DataInput 和 DataOutput 接口</strong></li><li>在提供字节流的读写手段同时，以统一的形式向输入流中写入 boolean，int，long，double 等基本数据类型，并可以再次把基本数据类型的值读取回来。</li><li>提供了字符串读写的手段</li></ol><p>数据流可以连接一个已经建立好的数据对象，例如网络连接、文件等。数据流可以通过如下方式建立：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1322" mdtype="fences">FileInputStream fis = new FileInputStream("file1.txt");
FileOutputStream fos = new FileOutputStream("file2.txt");
DataInputStream dis = new DataInputStream(fis);
DataOutputStream dos = new DataOutputStream(fos);
</pre><h4><a name='header-n1323' class='md-header-anchor '></a>5、标准流、内存读写流、顺序输入流</h4><p><strong>标准流：</strong></p><p>语言包 java.lang 中的 System 类管理标准输入/输出流和错误流。
System.in<code>从 InputStream 中继承而来，用于从标准输入设备中获取输入数据（通常是键盘）</code>System.out<code>从 PrintStream 中继承而来，把输入送到缺省的显示设备（通常是显示器）</code>System.err`也是从 PrintStream 中继承而来，把错误信息送到缺省的显示设备（通常是显示器）
每当 main 方法被执行时，就会自动生产上述三个对象。</p><p><strong>内存读写流：</strong></p><p>为了支持在内存上的 I/O，java.io 中提供了类：ByteArrayInputStream、ByteArrayOutputStream 和 StringBufferInputStream</p><ol start='' ><li>ByteArrayInputStream 可以从指定的字节数组中读取数据</li><li>ByteArrayOutputStream 中提供了缓冲区可以存放数据（缓冲区大小可以在构造方法中设定，缺省为 32），可以用 write() 方法向其中写入数据，然后用 toByteArray() 方法将缓冲区中的有效字节写到字节数组中去。size() 方法可以知道写入的字节数；reset() 可以丢弃所有内容。</li><li>StringBufferInputStream 与 ByteArrayInputStream 相类似，不同点在于它是从字符缓冲区 StringBuffer 中读取 16 位的 Unicode 数据，而不是 8 位的字节数据（已被 StringReader 取代）</li></ol><p><strong>顺序输入流</strong></p><p>java.io 中提供了类 SequenceInputStream，使应用程序可以将几个输入流顺序连接起来。顺序输入流提供了将多个不同的输入流统一为一个输入流的功能，这使得程序可能变得更加简洁。</p><p>例如：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1338" mdtype="fences">FileInputStream f1,f2;
String s;
f1 = new FileInputStream("file1.txt");
f2 = new FileInputStream("file2.txt");
SequenceInputStream fs = new SequenceInputStream(f1,f2);
DataInputeStream ds = new DataInputStream(fs);
while((s = ds.readLine()) != null) {
    System.out.println(s);
}
</pre><h3><a name='header-n1339' class='md-header-anchor '></a>二、字符流</h3><h4><a name='header-n1340' class='md-header-anchor '></a>1、基类：Reader 和 Writer</h4><p><strong>字符流以字符为单位，根据码表映射字符，一次可能读多个字节，只能处理字符类型的数据。</strong></p><p>同类 InputStream 和 OutputStream 一样，Reader 和 Writer 也是抽象类，只提供了一系列用于字符流处理的接口。它们的方法与类 InputStream 和 OutputStream 类似，只不过其中的参数换成字符或字符数组。</p><p>Reader 是所有的输入字符流的父类，它是一个抽象类：</p><figure><table><thead><tr><th>方法</th><th>返回值</th></tr></thead><tbody><tr><td>close()</td><td>void</td></tr><tr><td>mark (int readAheadLimit)</td><td>void</td></tr><tr><td>markSupported()</td><td>boolean</td></tr><tr><td>read()</td><td>int</td></tr><tr><td>read(char[] cbuf, int off,int len)</td><td>int</td></tr><tr><td>ready()</td><td>boolean</td></tr><tr><td>reset()</td><td>void</td></tr><tr><td>skip(long n)</td><td>long</td></tr></tbody></table></figure><p>Writer 是所有的输出字符流的父类，它是一个抽象类。 Writer 的方法：</p><figure><table><thead><tr><th>方法</th><th>返回值</th></tr></thead><tbody><tr><td>close()</td><td>void</td></tr><tr><td>flush()</td><td>void</td></tr><tr><td>write(char[] cbuf)</td><td>void</td></tr><tr><td>write(char[] cbuf, int off,int len)</td><td>void</td></tr><tr><td>write(int c)</td><td>void</td></tr><tr><td>write(String str)</td><td>void</td></tr><tr><td>write(String str, int off, int len)</td><td>void</td></tr></tbody></table></figure><p>&nbsp;</p><h4><a name='header-n1399' class='md-header-anchor '></a>2、InputStreamReader 和 OutputStreamWriter</h4><p>InputStreamReader 和 OutputStreamWriter 是 java.io 包中用于处理字符流的最基本的类，用来在字节流和字符流之间作为中介：从字节输入流读入字节，并按编码规范转换为字符；往字节输出流写字符时先将字符按编码规范转换为字节。使用这两者进行字符处理时，在构造方法中应指定一定的平台规范，以便把以字节方式表示的流转换为特定平台上的字符表示。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1401" mdtype="fences">InputStreamReader(InputStream in); //缺省规范说明

//指定规范 enc
InputStreamReader(InputStream in, String enc);

OutputStreamWriter(OutputStream out); //缺省规范说明

//指定规范 enc
OutputStreamWriter(OutputStream out, String enc);
</pre><p>如果读取的字符流不是来自本地时（比如网上某处与本地编码方式不同的机器），那么在构造字符输入流时就不能简单地使用缺省编码规范，而应该指定一种统一的编码规范“ISO 8859_1”，这是一种映射到 ASCCII 码的编码方式，能够在不同平台之间正确转换字符。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1403" mdtype="fences">InputStreamReader ir = new InputStreamReader(is,"8859_1");
</pre><p>&nbsp;</p><h4><a name='header-n1405' class='md-header-anchor '></a>3、缓存流</h4><p>除了 read() 和 write() 方法外，它还提供了整行字符处理方法：</p><ol start='' ><li>public String readLine()：BufferedReader 的方法，从输入流中读取一行字符，行结束标志<code>\n</code>、<code>\r</code>或者两者一起（这是根据系统而定的）</li><li>public void newLine()：BufferedWriter 的方法，向输出流中写入一个行结束标志，它不是简单地换行符<code>\n</code>或<code>\r</code>，而是系统定义的行隔离标志（line separator）。</li></ol><p>例子：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1413" mdtype="fences" style="break-inside: unset;">import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;

public class FileToUnicode {
    public static void main(String args[]) {
        try {
            FileInputStream fis = new FileInputStream("file1.txt");
            InputStreamReader dis = new InputStreamReader(fis);
            BufferedReader reader = new BufferedReader(dis);
            String s;
            //每次读取一行，当改行为空时结束
            while((s = reader.readLine()) != null){
                System.out.println("read:" + s);
            }
            dis.close();
        }
        catch(IOException e) {
            System.out.println(e);
        }
    }
}
</pre><h4><a name='header-n1414' class='md-header-anchor '></a>4、其它字符流类</h4><p>这里我们就列举一下有哪些类，具体的就不再讲解了。</p><ol start='' ><li><p>对字符数组进行处理： CharArrayReader、CharArrayWrite</p></li><li><p>对文本文件进行处理：FileReader、FileWriter</p></li><li><p>对字符串进行处理：StringReader、StringWriter</p></li><li><p>过滤字符流：FilterReader、FileterWriter</p></li><li><p>管道字符流：PipedReader、PipedWriter</p></li><li><p>行处理字符流：LineNumberReader</p></li><li><p>打印字符流：PrintWriter</p><p>&nbsp;</p><p>&nbsp;</p></li></ol><h3><a name='header-n1433' class='md-header-anchor '></a>三、File文件操作</h3><p><a href='https://www.shiyanlou.com/courses/109/labs/1123/document/' target='_blank' class='url'>https://www.shiyanlou.com/courses/109/labs/1123/document/</a></p><p>java.io 定义的大多数类都是流式操作，但 File 类不是。它直接处理文件和文件系统。File 类没有指定信息怎样从文件读取或向文件存储；它<strong>描述了文件本身的属性</strong>。File 对象用来获取或处理与磁盘文件相关的信息，例如权限，时间，日期和目录路径。此外，File 还浏览子目录层次结构。Java 中的目录当成 File 对待，它具有附加的属性——一个可以被 list( )方法检测的文件名列表。</p><p>File 的构造方法：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1437" mdtype="fences">//根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。 
File(File parent, String child) 

//通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例       
File(String pathname) 

// 根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例
File(String parent, String child) 

//通过将给定的 file: URI 转换为一个抽象路径名来创建一个新的 File 实例
File(URI uri) 
</pre><p>例如:</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1439" mdtype="fences">//一个目录路径参数
File f1 = new File("/Users/mumutongxue/");

//对象有两个参数——路径和文件名
File f2 = new File("/Users/mumutongxue/","a.bat");

//指向f1文件的路径及文件名
File f3 = new File(f1,"a.bat");
</pre><p>&nbsp;</p><h3><a name='header-n1441' class='md-header-anchor '></a>四、RandomAccessFile类</h3><ol start='' ><li>该对象只能操作文件，所以构造函数接收两种类型的参数：a.字符串文件路径；b.File对象。</li><li><strong>该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw)，支持随机访问文件，可以访问文件的任意位置；打开文件时文件指针在开头pointer=0；</strong></li><li><strong>写方法 raf.write(int) ---&gt; 只写一个字节（后八位），同时指针指向下一个位置，或者也可以直接写入一个字节数组byte[]，或者直接调用writeInt(i)</strong></li><li>读方法int b=raf.read() ---&gt;读一个字节</li></ol><p>&nbsp;</p><p>RandomAccessFile 提供了支持随机文件操作的方法：</p><ol start='' ><li>readXXX()或者 writeXXX():如 ReadInt(),ReadLine(),WriteChar(),WriteDouble()等</li><li>int skipBytes(int n):将指针向下移动若干字节</li><li>length():返回文件长度</li><li>long getFilePointer():返回指针当前位置</li><li><strong>void seek(long pos):将指针调用所需位置</strong></li></ol><p>在生成一个随机文件对象时，除了要指明文件对象和文件名之外，还需要指明访问文件的模式。</p><p>我们来看看 RandomAccessFile 的构造方法：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1466" mdtype="fences">RandomAccessFile(File file,String mode)
RandomAccessFile(String name,String mode)
</pre><p>mode 的取值：</p><ul><li><code>r</code>:只读，任何写操作都讲抛出 IOException</li><li><code>rw</code>:读写，文件不存在时会创建该文件，文件存在是，原文件内容不变，通过写操作改变文件内容。</li><li><code>rws</code>:打开以便读取和写入，对于 &quot;rw&quot;，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。</li><li><code>rwd</code>:打开以便读取和写入，对于 &quot;rw&quot;，还要求对文件内容的每个更新都同步写入到底层存储设备。</li></ul><p>例子：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1478" mdtype="fences" style="break-inside: unset;">import java.io.IOException;
import java.io.RandomAccessFile;

public class  FileDemo {
    public static void main(String[] args){

            int data_arr[] = {12, 32, 43, 45, 1, 5};
            try {
                RandomAccessFile randf=new RandomAccessFile("temp.dat","rw");
                for(int i = 0; i &lt; data_arr.length; i++){
                    randf.writeInt(data_arr[i]);
                }
                for(int i = data_arr.length-1 ; i &gt;= 0; i--){
                    //int 数据占4个字节
                    randf.seek(i * 4L);
                    System.out.println(randf.readInt());
                }
                randf.close();
            }catch(IOException e){
                System.out.println("File access error" + e);
            }
    }
}

输出结果：
5  1  45  43  32  12
</pre><p>&nbsp;</p><h3><a name='header-n1480' class='md-header-anchor '></a>五、Serializable（序列化）</h3><p>  <strong>1、序列化是干什么的？</strong>
       简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。</p><p><strong>2、什么情况下需要序列化</strong> <br/>    a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；
    b）当你想用套接字在网络上传送对象的时候；
    c）当你想通过RMI传输对象的时候；  </p><h1><a name='header-n1483' class='md-header-anchor '></a>Java并发性和多线程</h1><h3><a name='header-n1484' class='md-header-anchor '></a>进程</h3><p>讲到线程，又不得不提进程了~</p><p>进程我们估计是很了解的了，在windows下打开任务管理器，可以发现我们在操作系统上运行的程序都是进程：</p><p><img src='https://segmentfault.com/img/remote/1460000014428193?w=1226&amp;h=742' alt='img' referrerPolicy='no-referrer' /></p><p><strong>进程的定义：</strong></p><blockquote><p>进程是<strong>程序的一次执行</strong>，进程是一个程序及其数据在处理机上顺序执行时所发生的<strong>活动</strong>，进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资<strong>源分配和调度</strong>的一个<strong>独立</strong>单位</p></blockquote><ul><li><strong>进程是系统进行资源分配和调度的独立单位。每一个进程都有它自己的内存空间和系统资源</strong></li></ul><h3><a name='header-n1494' class='md-header-anchor '></a>并行和并发</h3><p><strong>并行：</strong></p><ul><li>并行性是指<strong>同一时刻内</strong>发生两个或多个事件。</li><li>并行是在<strong>不同</strong>实体上的多个事件</li></ul><p><strong>并发：</strong></p><ul><li>并发性是指<strong>同一时间间隔内</strong>发生两个或多个事件。</li><li>并发是在<strong>同一实体</strong>上的多个事件</li></ul><p>由此可见：并行是针对进程的，<strong>并发是针对线程的</strong>。</p><blockquote><ul><li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li><li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li></ul></blockquote><h3><a name='header-n1514' class='md-header-anchor '></a>线程和进程的区别？</h3><ul><li><p><strong>进程是资源分配的最小单位，线程是程序执行的最小单位。</strong></p></li><li><p>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此<strong>CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</strong></p></li><li><p>线程之间的通信更方便，同一进程下的<strong>线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。</strong>不过如何处理好同步与互斥是编写多线程程序的难点。</p></li><li><p>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p><p>&nbsp;</p><p><strong>为什么会有线程？</strong></p><p>　　每个进程都有自己的地址空间，即进程空间，在网络或多用户换机下，一个服务器通常需要接收大量不确定数量用户的并发请求，为每一个请求都创建一个进程显然行不通（系统开销大响应用户请求效率低），因此操作系统中线程概念被引进。</p></li></ul><p>&nbsp;</p><h2><a name='header-n1528' class='md-header-anchor '></a>线程</h2><h3><a name='header-n1529' class='md-header-anchor '></a>线程状态</h3><p><a href='https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20' target='_blank' class='url'>https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20</a>并发.md#一线程状态转换</p><p><img src='https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/adfb427d-3b21-40d7-a142-757f4ed73079.png' alt='img' referrerPolicy='no-referrer' /></p><p><strong>新建（New）</strong></p><p>创建后尚未启动。</p><p><strong>可运行（Runnable）</strong></p><p>可能正在运行，也可能正在等待 CPU 时间片。</p><p>包含了操作系统线程状态中的 Running 和 Ready。</p><p><strong>阻塞（Blocked）</strong></p><p>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p><blockquote><p>共享锁就是允许多个线程同时获取一个锁，一个锁可以同时被多个线程拥有。</p><p>排它锁，也称作独占锁，一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁。</p></blockquote><p><strong>无限期等待（Waiting）</strong></p><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p><figure><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></figure><p><strong>限期等待（Timed Waiting）</strong></p><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p><p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p><p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p><figure><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></figure><p><strong>死亡（Terminated）</strong></p><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><p>&nbsp;</p><h3><a name='header-n1585' class='md-header-anchor '></a>线程的使用</h3><p>有三种使用线程的方法：</p><ul><li><strong>实现 Runnable 接口</strong>，重写 run()，new出来后作为参数传入Thred再调用start；</li><li><strong>实现 Callable 接口</strong>；与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</li><li><strong>继承 Thread 类</strong>，重写run方法，直接new出来然后start。</li></ul><p><strong>实现 Runnable 和 Callable 接口</strong>的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，<strong>因此最后还需要通过 Thread 来调用</strong>。可以说任务是通过线程驱动从而执行的。</p><p><strong>实现接口会更好一些</strong>，因为：</p><ul><li><p><strong>Java 不支持多重继承</strong>，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</p></li><li><p>类可能只要求可执行就行，<strong>继承整个 Thread 类开销过大</strong>。</p></li><li><p>将并发<strong>运行任务和运行机制解耦</strong></p><p>&nbsp;</p></li></ul><h4><a name='header-n1604' class='md-header-anchor '></a>run()和start()方法区别：</h4><ul><li><code>run()</code>:仅仅是<strong>封装被线程执行的代码</strong>，直接调用是普通方法</li><li><code>start()</code>:首先<strong>启动了线程</strong>，然后再<strong>由jvm去调用该线程的run()方法。</strong></li></ul><p><strong>jvm虚拟机的启动是单线程的还是多线程的?</strong></p><ul><li><strong>是多线程的</strong>。不仅仅是启动main线程，还至少会启动垃圾回收线程的，不然谁帮你回收不用的内存~</li></ul><p>&nbsp;</p><h3><a name='header-n1615' class='md-header-anchor '></a>与线程生命周期相关的<strong>方法</strong></h3><h5><a name='header-n1616' class='md-header-anchor '></a>一、sleep</h5><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。等时间到了，<strong>进入的是就绪状态而并非是运行状态</strong>！</p><p>&nbsp;</p><h6><a name='header-n1619' class='md-header-anchor '></a><strong>wait() 和 sleep() 的区别</strong></h6><ul><li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><h5><a name='header-n1625' class='md-header-anchor '></a>二、yield方法</h5><p>调用yield方法会先<strong>让别的线程执行</strong>，但是<strong>不确保真正让出</strong>，而且也只是建议具有相同优先级的其它线程可以运行。</p><ul><li>意思是：<strong>我有空，可以的话，让你们先执行</strong></li></ul><h5><a name='header-n1630' class='md-header-anchor '></a>三、join方法</h5><p>调用join方法，会等待<strong>该线程</strong>执行<strong>完毕后才执行别的线程</strong>~</p><h5><a name='header-n1632' class='md-header-anchor '></a>四、interrupt方法</h5><p>线程中断在之前的版本有stop方法，但是被设置过时了。现在已经<strong>没有强制线程终止</strong>的方法了！</p><ul><li>要注意的是：interrupt<strong>不会真正停止</strong>一个线程，它仅仅是给这个线程发了一个信号告诉它，它应该要结束了(明白这一点非常重要！)</li><li>也就是说：Java设计者实际上是<strong>想线程自己来终止</strong>，通过上面的<strong>信号</strong>，就可以判断处理什么业务了。</li><li>具体到底中断还是继续运行，应该<strong>由被通知的线程自己处理</strong>，调用interrupt()<strong>并不是要真正终止掉当前线程</strong>，仅仅是设置了一个中断标志。这个中断标志可以给我们用来判断<strong>什么时候该干什么活</strong>！什么时候中断<strong>由我们自己来决定</strong>，这样就可以<strong>安全地终止线程</strong>了</li></ul><blockquote><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p><p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1645" mdtype="fences">public class InterruptExample {

 private static class MyThread2 extends Thread {
     @Override
     public void run() {
         while (!interrupted()) {
             // ..
         }
         System.out.println("Thread end");
     }
 }
}
</pre></blockquote><h6><a name='header-n1642' class='md-header-anchor '></a>InterruptedException</h6><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><p>&nbsp;</p><h3><a name='header-n1648' class='md-header-anchor '></a>线程池</h3><p>为每个请求都开一个新的线程虽然<strong>理论上是可以</strong>的，但是会有<strong>缺点</strong>：</p><ul><li><strong>线程生命周期的开销非常高</strong>。每个线程都有自己的生命周期，<strong>创建和销毁线程</strong>所花费的时间和资源可能比处理客户端的任务花费的时间和资源更多，并且还会有某些<strong>空闲线程也会占用资源</strong>。</li><li>程序的稳定性和健壮性会下降，每个请求开一个线程。如果受到了恶意攻击或者请求过多(内存不足)，程序很容易就奔溃掉了。</li></ul><p>所以说：我们的<strong>线程最好是交由线程池来管理</strong>，这样可以减少对线程生命周期的管理，一定程度上提高性能。</p><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p><p><strong>主要有三种 Executor：</strong></p><ul><li>CachedThreadPool：一个任务创建一个线程，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。；</li><li>FixedThreadPool：所有任务只能使用固定大小的线程，超出的线程会在队列中等待；</li><li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1665" mdtype="fences">public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    for (int i = 0; i &lt; 5; i++) {
    // 向线程池提交一个任务（其实就是通过线程池来启动一个线程）
        executorService.execute(new MyRunnable());
    }
    executorService.shutdown();
}
</pre><h3><a name='header-n1666' class='md-header-anchor '></a>synchronized</h3><h5><a name='header-n1667' class='md-header-anchor '></a>1. 同步一个代码块</h5><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1668" mdtype="fences">public void func() {
    synchronized (this) {
        // ...
    }
}
</pre><p>它<strong>只作用于同一个对象</strong>，如果调用两个对象上的同步代码块，就不会进行同步。</p><p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1671" mdtype="fences" style="break-inside: unset;">public class SynchronizedExample {

    public void func1() {
        synchronized (this) {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + " ");
            }
        }
    }
}
public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func1());
    executorService.execute(() -&gt; e1.func1());
}
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</pre><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1673" mdtype="fences">public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func1());
    executorService.execute(() -&gt; e2.func1());
}
0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9
</pre><h5><a name='header-n1674' class='md-header-anchor '></a>2. 同步一个方法</h5><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1675" mdtype="fences">public synchronized void func () {
    // ...
}
</pre><p>它和同步代码块一样，<strong>作用于同一个对象</strong>。</p><h5><a name='header-n1677' class='md-header-anchor '></a>3. 同步一个类</h5><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1678" mdtype="fences">public void func() {
    synchronized (SynchronizedExample.class) {
        // ...
    }
}
</pre><p><strong>作用于整个类</strong>，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1680" mdtype="fences" style="break-inside: unset;">public class SynchronizedExample {

    public void func2() {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + " ");
            }
        }
    }
}
public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func2());
    executorService.execute(() -&gt; e2.func2());
}
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</pre><h5><a name='header-n1681' class='md-header-anchor '></a>4. 同步一个静态方法</h5><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1682" mdtype="fences">public synchronized static void fun() {
    // ...
}
</pre><p><strong>作用于整个类</strong>。</p><p>&nbsp;</p><h3><a name='header-n1685' class='md-header-anchor '></a>Lock显式锁</h3><p><strong>简单概括</strong>一下：</p><ul><li>Lock方式来获取锁<strong>支持中断、超时不获取、是非阻塞的</strong></li><li><strong>提高了语义化</strong>，哪里加锁，哪里解锁都得写出来</li><li><strong>Lock显式锁可以给我们带来很好的灵活性，但同时我们必须手动释放锁</strong></li><li>支持Condition条件对象</li><li><strong>允许多个读线程同时访问共享资源</strong></li></ul><h3><a name='header-n1698' class='md-header-anchor '></a>synchronized锁和Lock锁使用哪个</h3><blockquote><p><a href='https://segmentfault.com/a/1190000014571149' target='_blank' class='url'>https://segmentfault.com/a/1190000014571149</a></p></blockquote><p>前面说了，Lock显式锁给我们的程序带来了很多的灵活性，很多特性都是Synchronized锁没有的。那Synchronized锁有没有存在的必要？？</p><p>必须是有的！！Lock锁在刚出来的时候很多性能方面都比Synchronized锁要好，但是从JDK1.6开始Synchronized锁就做了各种的优化</p><ul><li>优化操作：适应自旋锁，锁消除，锁粗化，轻量级锁，偏向锁。</li><li>详情可参考：<a href='https://blog.csdn.net/chenssy/article/details/54883355' target='_blank' class='url'>https://blog.csdn.net/chenssy/article/details/54883355</a></li></ul><p>所以，到现在Lock锁和Synchronized锁的性能其实<strong>差别不是很大</strong>！而Synchronized锁用起来又特别简单。<strong>Lock锁还得顾忌到它的特性，要手动释放锁才行</strong>(如果忘了释放，这就是一个隐患)</p><p>所以说，我们<strong>绝大部分时候还是会使用Synchronized锁</strong>，用到了Lock锁提及的特性，带来的灵活性才会考虑使用Lock显式锁~</p><blockquote><p><a href='https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20' target='_blank' class='url'>https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20</a>并发.md#synchronized</p></blockquote><p>比较</p><p><strong>1. 锁的实现</strong></p><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><p><strong>2. 性能</strong></p><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><p><strong>3. 等待可中断</strong></p><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><p><strong>4. 公平锁</strong></p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><p><strong>5. 锁绑定多个条件</strong></p><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><p><strong>使用选择</strong></p><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p><p>&nbsp;</p><h3><a name='header-n1728' class='md-header-anchor '></a>线程之间的协作wait() notify() notifyAll()</h3><p>1、wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写。</p><p>2、wait()使当前线程阻塞，前提是 必须先获得锁，一般配合synchronized 关键字使用，即，一般在synchronized 同步代码块里使用 wait()、notify/notifyAll() 方法。</p><p>3、 由于 wait()、notify/notifyAll() 在synchronized 代码块执行，说明当前线程一定是获取了锁的。</p><p>当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。</p><p>只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁。</p><p>也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程 </p><p>4、wait() 需要被try catch包围，中断也可以使wait等待的线程唤醒。</p><p>5、notify 和wait 的顺序不能错，如果A线程先执行notify方法，B线程在执行wait方法，那么B线程是无法被唤醒的。</p><p>6、notify 和 notifyAll的区别</p><p>notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。</p><h3><a name='header-n1739' class='md-header-anchor '></a>await() signal() signalAll()</h3><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p><p>使用 Lock 来获取一个 Condition 对象。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1743" mdtype="fences" style="break-inside: unset;">public class AwaitSignalExample {

    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void before() {
        lock.lock();
        try {
            System.out.println("before");
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public void after() {
        lock.lock();
        try {
            condition.await();
            System.out.println("after");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
    AwaitSignalExample example = new AwaitSignalExample();
    executorService.execute(() -&gt; example.after());
    executorService.execute(() -&gt; example.before());
}
before
after
</pre><h3><a name='header-n1744' class='md-header-anchor '></a>J.U.C - AQS</h3><p>java.util.concurrent下的AbstractQueuedSynchronizer抽象类简称为AQS</p><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p><p>&nbsp;</p><p>概括一下AQS到底是什么：</p><ul><li><p><strong>juc包中很多可阻塞的类都是基于AQS构建的</strong></p><ul><li>AQS可以说是一个给予实现同步锁、同步器的一个<strong>框架</strong>，很多实现类都在它的的基础上构建的</li></ul></li><li><p>在AQS中实现了对<strong>等待队列的默认实现</strong>，子类只要重写部分的代码即可实现(<strong>大量用到了模板代码</strong>)</p></li></ul><p>&nbsp;</p><h4><a name='header-n1758' class='md-header-anchor '></a>信号量</h4><h5><a name='header-n1759' class='md-header-anchor '></a>CountDownLatch</h5><p>用来控制一个线程等待多个线程。</p><p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p><h5><a name='header-n1762' class='md-header-anchor '></a>CyclicBarrier</h5><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p><h5><a name='header-n1767' class='md-header-anchor '></a>Semaphore</h5><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1770" mdtype="fences" style="break-inside: unset;">public class SemaphoreExample {

    public static void main(String[] args) {
        final int clientCount = 3;
        final int totalRequestCount = 10;
        Semaphore semaphore = new Semaphore(clientCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i &lt; totalRequestCount; i++) {
            executorService.execute(()-&gt;{
                try {
                    semaphore.acquire();
                    System.out.print(semaphore.availablePermits() + " ");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release();
                }
            });
        }
        executorService.shutdown();
    }
}
2 1 2 2 2 2 2 1 2 2
</pre><h3><a name='header-n1771' class='md-header-anchor '></a>ThreadLocal</h3><p>ThreadLocal提供了线程的局部变量，每个线程都可以通过<code>set()</code>和<code>get()</code>来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，<strong>实现了线程的数据隔离</strong>～。</p><p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p><p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p><h3><a name='header-n1775' class='md-header-anchor '></a>原子性</h3><p><strong>原子性</strong>就是执行<strong>某一个操作是不可分割的</strong>，</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1777" mdtype="fences">- 比如上面所说的`count++`操作，它就不是一个原子性的操作，它是分成了三个步骤的来实现这个操作的~
- **JDK中有atomic包提供给我们实现原子性操作**~
</pre><h3><a name='header-n1778' class='md-header-anchor '></a>可见性</h3><p>保证<strong>该变量对所有线程的可见性</strong></p><ul><li>在多线程的环境下：当这个变量修改时，<strong>所有的线程都会知道该变量被修改了</strong>，也就是所谓的“可见性”</li></ul><p>&nbsp;</p><h3><a name='header-n1784' class='md-header-anchor '></a>volatile</h3><p>使用了volatile修饰的变量<strong>保证了三点</strong>：</p><ul><li><strong>一旦你完成写入，任何访问这个字段的线程将会得到最新的值</strong></li><li>在你写入前，<strong>会保证所有之前发生的事已经发生</strong>，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。</li><li><strong>volatile可以防止重排序</strong>(重排序指的就是：程序执行的时候，CPU、编译器可能会<strong>对执行顺序做一些调整</strong>，导致执行的顺序并不是从上往下的。从而出现了一些意想不到的效果)。而如果声明了volatile，那么CPU、编译器就会知道<strong>这个变量是共享的</strong>，不会被缓存在寄存器或者其他不可见的地方。</li></ul><p>一般来说，<strong>volatile大多用于标志位上(判断操作)</strong>,满足下面的条件才应该使用volatile修饰变量：</p><ul><li><strong>修改变量时不依赖变量的当前值</strong>(因为volatile是不保证原子性的)</li><li><strong>该变量不会纳入到不变性条件中</strong>(该变量是可变的)</li><li><strong>在访问变量的时候不需要加锁</strong>(加锁就没必要使用volatile这种轻量级同步机制了)</li></ul><h3><a name='header-n1801' class='md-header-anchor '></a>线程安全</h3><p><strong>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</strong></p><p>线程安全有以下几种实现方式：</p><h4><a name='header-n1804' class='md-header-anchor '></a>不可变</h4><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p><p>不可变的类型：</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li></ul><p>&nbsp;</p><h4><a name='header-n1817' class='md-header-anchor '></a>非阻塞同步</h4><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><h4><a name='header-n1820' class='md-header-anchor '></a>无同步方案</h4><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p><p>&nbsp;</p></div>
</body>
</html>